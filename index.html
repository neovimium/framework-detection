<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Browser Automation Detection</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #333;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }
        
        .results {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #f9f9f9;
            min-height: 200px;
            max-height: 500px;
            overflow-y: auto;
        }
        
        .detection {
            margin-bottom: 10px;
            padding: 8px;
            border-left: 4px solid #ff6b6b;
            background-color: #fff0f0;
        }
        
        .no-detection {
            color: #2e7d32;
            font-weight: bold;
        }
        
        .timestamp {
            color: #888;
            font-size: 0.8em;
            margin-top: 4px;
        }
        
        .info-box {
            background-color: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 10px 15px;
            margin: 15px 0;
            border-radius: 4px;
        }
        
        .info-box h3 {
            margin-top: 0;
            color: #0d47a1;
        }

        .category {
            margin-top: 15px;
            font-weight: bold;
            color: #333;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Browser Automation Detection</h1>
        <p>This page runs various detection techniques to identify browser automation frameworks like Selenium, Puppeteer, Playwright, and others.</p>
        <div id="status">Running detection checks...</div>
        <div class="info-box">
            <h3>About This Tool</h3>
            <p>This detector is designed to detect <strong>actual automation tools</strong>, not normal browser features. The script has been calibrated to minimize false positives in standard browser environments.</p>
            <p>Some browsers may naturally have properties that resemble automation tools, but these are not included in our detection algorithm.</p>
        </div>
        <div id="results" class="results">
            <p>Detection results will appear here...</p>
        </div>
    </div>

    <script>
        // Automation Detection Script
        (function() {
            // Utility functions
            const utils = {
                // Checks if a property exists on an object
                hasProperty: function(obj, prop) {
                    try {
                        return prop in obj;
                    } catch (e) {
                        return false;
                    }
                },
                
                // Checks if a method is non-native (overridden)
                isMethodNonNative: function(method) {
                    if (!method) return false;
                    try {
                        return !Function.prototype.toString.call(method).includes('[native code]');
                    } catch (e) {
                        return false;
                    }
                },
                
                // Gets property descriptor
                getPropertyDescriptor: function(obj, prop) {
                    try {
                        return Object.getOwnPropertyDescriptor(obj, prop);
                    } catch (e) {
                        return null;
                    }
                },
                
                // Checks if running in iframe
                isInIframe: function() {
                    try {
                        return window.self !== window.top;
                    } catch (e) {
                        return true; // Access denied means we're in an iframe
                    }
                },
                
                // Checks if string contains a substring
                stringContains: function(str, substring) {
                    return String(str).indexOf(substring) > -1;
                },
                
                // Get all window properties up the prototype chain
                getAllWindowProperties: function(obj) {
                    let props = [];
                    do {
                        props = props.concat(Object.getOwnPropertyNames(obj));
                    } while (obj = Object.getPrototypeOf(obj));
                    return props;
                }
            };
            
            // Results collector
            const results = {
                detections: [],
                
                add: function(category, name, details) {
                    this.detections.push({
                        category: category,
                        name: name,
                        details: details || '',
                        timestamp: new Date().toISOString()
                    });
                    this.updateUI();
                },
                
                updateUI: function() {
                    const resultsElem = document.getElementById('results');
                    if (this.detections.length === 0) {
                        resultsElem.innerHTML = '<p class="no-detection">No automation detected.</p>';
                        return;
                    }
                    
                    let html = '';
                    let currentCategory = '';
                    
                    for (const detection of this.detections) {
                        if (detection.category !== currentCategory) {
                            currentCategory = detection.category;
                            html += `<div class="category">${currentCategory}</div>`;
                        }
                        
                        html += `
                            <div class="detection">
                                <strong>${detection.name}</strong>
                                ${detection.details ? ': ' + detection.details : ''}
                                <div class="timestamp">${new Date(detection.timestamp).toLocaleTimeString()}</div>
                            </div>
                        `;
                    }
                    
                    resultsElem.innerHTML = html;
                    document.getElementById('status').textContent = `Detection completed. Found ${this.detections.length} indicators of automation.`;
                }
            };
            
            // WebDriver Detections
            const webDriverChecks = {
                run: function() {
                    // Check navigator.webdriver property
                    if (navigator.webdriver) {
                        results.add('WebDriver', 'navigator.webdriver is present', 'This property is explicitly set to true by WebDriver implementations');
                    }
                    
                    // Check for WebDriver attributes on HTML elements
                    const checkAttributes = () => {
                        const attributesToCheck = ['selenium', 'webdriver', 'driver', 'cd_frame_id_'];
                        for (const attr of attributesToCheck) {
                            if (document.documentElement.getAttribute(attr)) {
                                results.add('WebDriver', `Document has '${attr}' attribute`, 
                                    `Value: ${document.documentElement.getAttribute(attr)}`);
                            }
                            
                            // Check iframe elements
                            const iframes = [...document.querySelectorAll('iframe'), ...document.querySelectorAll('frame')];
                            for (const iframe of iframes) {
                                if (iframe.getAttribute(attr)) {
                                    results.add('WebDriver', `iframe has '${attr}' attribute`, 
                                        `Value: ${iframe.getAttribute(attr)}`);
                                }
                            }
                        }
                    };
                    
                    // Execute check or wait for document to be ready
                    if (document.readyState === 'complete') {
                        checkAttributes();
                    } else {
                        document.addEventListener('DOMContentLoaded', checkAttributes);
                    }
                    
                    // Check for modified webdriver property
                    const navigatorDesc = utils.getPropertyDescriptor(Object.getPrototypeOf(navigator), 'webdriver');
                    if (navigatorDesc && navigatorDesc.get && utils.isMethodNonNative(navigatorDesc.get)) {
                        results.add('WebDriver', 'navigator.webdriver getter is modified', 
                            'The getter method for this property has been overridden');
                    }
                    
                    // Check for webdriver-related events
                    const webdriverEvents = [
                        'webdriver-evaluate', 'driver-evaluate', 'selenium-evaluate',
                        'webdriverCommand', 'webdriver-evaluate-response'
                    ];
                    
                    for (const eventType of webdriverEvents) {
                        const detector = function(e) {
                            if (e.type === eventType) {
                                results.add('WebDriver', `WebDriver event detected: ${eventType}`);
                                document.removeEventListener(eventType, detector);
                            }
                        };
                        document.addEventListener(eventType, detector);
                    }
                }
            };
            
            // Automation Framework Detection
            const automationFrameworkChecks = {
                run: function() {
                    // Check for automation globals
                    const automationGlobals = [
                        { name: '_phantom', alias: 'PhantomJS' },
                        { name: 'callPhantom', alias: 'PhantomJS' },
                        { name: '_selenium', alias: 'Selenium' },
                        { name: 'callSelenium', alias: 'Selenium' },
                        { name: '_Selenium_IDE_Recorder', alias: 'Selenium IDE' },
                        { name: 'domAutomation', alias: 'Chrome domAutomation' },
                        { name: 'domAutomationController', alias: 'Chrome domAutomation' },
                        { name: '__nightmare', alias: 'Nightmare.js' },
                        { name: '__webdriver_script_fn', alias: 'WebDriver' },
                        { name: '__webdriver_script_function', alias: 'WebDriver' },
                        { name: '__webdriver_script_func', alias: 'WebDriver' },
                        { name: '__webdriver_evaluate', alias: 'WebDriver' },
                        { name: '__selenium_evaluate', alias: 'Selenium' },
                        { name: '__fxdriver_evaluate', alias: 'Firefox WebDriver' },
                        { name: '__driver_unwrapped', alias: 'WebDriver' },
                        { name: '__webdriver_unwrapped', alias: 'WebDriver' },
                        { name: '__driver_evaluate', alias: 'WebDriver' },
                        { name: '__selenium_unwrapped', alias: 'Selenium' },
                        { name: '__fxdriver_unwrapped', alias: 'Firefox WebDriver' },
                        { name: '__$webdriverAsyncExecutor', alias: 'WebDriver' },
                        { name: 'fmget_targets', alias: 'Flash Microscope' }, 
                        { name: 'spawn', alias: 'Node.js environment' },
                        { name: 'emit', alias: 'Node.js environment' }
                    ];
                    
                    for (const global of automationGlobals) {
                        if (utils.hasProperty(window, global.name)) {
                            results.add('Automation Framework', `${global.alias} detected`, 
                                `Found global property: ${global.name}`);
                        }
                    }
                    
                    // Check for Chrome Debugger Protocol
                    if (window.chrome && window.chrome.csi && window.chrome.loadTimes) {
                        try {
                            window.webkitStorageInfo.queryUsageAndQuota(); // Will throw in CDP
                            window.chrome.runtime.sendMessage(); // This should throw without extensions
                        } catch(e) {
                            if (e.toString().indexOf("TypeError: Cannot read properties of undefined") === -1) {
                                // This is expected behavior in automation contexts
                                results.add('Automation Framework', 'Chrome Debugging Protocol', 
                                    'Error pattern suggests Chrome is being controlled via CDP');
                            }
                        }
                    }
                    
                    // Check for CDP-specific properties
                    if (window.cdc_adoQpoasnfa76pfcZLmcfl_ || 
                        utils.hasProperty(document, '$cdc_asdjflasutopfhvcZLmcfl_')) {
                        results.add('Automation Framework', 'Chrome DevTools Protocol', 
                            'Found CDP marker properties added by ChromeDriver');
                    }
                    
                    // Check for Puppeteer
                    const windowProps = Object.getOwnPropertyNames(window).slice(-300);
                    const cdcProps = windowProps.filter(prop => 
                        /^cdc_[a-zA-Z0-9]{22}_(Array|Promise|Symbol)$/.test(prop)
                    );
                    
                    if (cdcProps.length) {
                        results.add('Automation Framework', 'Puppeteer/ChromeDriver', 
                            `Found suspicious window properties: ${cdcProps.join(', ')}`);
                    }
                    
                    // Check for Playwright
                    try {
                        const iframe = document.createElement('iframe');
                        document.body.appendChild(iframe);
                        const iframeWindow = iframe.contentWindow;
                        
                        const regexMatchPrefix = iframeWindow.RegExp['$&'];
                        const hasMatchingPrefix = /[a-zA-Z]{3}\_[a-zA-Z]{22}\_(Array|Symbol|Promise)/i.test(regexMatchPrefix);
                        
                        if (hasMatchingPrefix) {
                            results.add('Automation Framework', 'Playwright', 
                                'Pattern in RegExp behavior indicates Playwright');
                        }
                        
                        document.body.removeChild(iframe);
                    } catch (e) {
                        // Iframe testing failed, ignore
                    }
                }
            };
            
            // Browser Environment Checks
            const browserEnvironmentChecks = {
                run: function() {
                    // Check for zero/small dimensions (headless)
                    if (screen.width <= 1 || screen.height <= 1) {
                        results.add('Browser Environment', 'Zero screen dimensions', 
                            `Screen size: ${screen.width}x${screen.height}`);
                    }
                    
                    if (screen.availWidth <= 1 || screen.availHeight <= 1) {
                        results.add('Browser Environment', 'Zero available screen dimensions', 
                            `Available screen size: ${screen.availWidth}x${screen.availHeight}`);
                    }
                    
                    // Check for suspicious user agent inconsistencies
                    if (/Chrome/.test(navigator.userAgent) && 
                        /Google Inc/.test(navigator.vendor) && 
                        !window.chrome) {
                        results.add('Browser Environment', 'Chrome user agent without chrome object', 
                            'This suggests a spoofed user agent');
                    }
                    
                    // Check if browser plugins are inconsistent (common in headless)
                    const plugins = navigator.plugins;
                    
                    // Find plugin by name and filename
                    const findPluginIndex = function(name, filename) {
                        for (let i = 0; i < plugins.length; i++) {
                            const plugin = plugins[i];
                            if (name && plugin.name === name && filename && plugin.filename === filename) {
                                return i;
                            }
                        }
                        return -1;
                    };

                    if (plugins.length > 0) {
                        const pdfViewerIndex = findPluginIndex("Chrome PDF Viewer", "internal-pdf-viewer");
                        const pdfViewer2Index = findPluginIndex("Chrome PDF Viewer", "mhjfbmdgcfjbbpaeojofohoefgiehjai");
                        const naclPluginIndex = findPluginIndex("Native Client", "internal-nacl-plugin");

                        const hasPdfViewerInconsistency = "Chrome PDF Viewer" in plugins && 
                                                         !("Chrome PDF Plugin" in plugins) && 
                                                         pdfViewerIndex !== -1 && 
                                                         pdfViewer2Index !== -1 && 
                                                         pdfViewer2Index < pdfViewerIndex && 
                                                         naclPluginIndex === -1;

                        if (hasPdfViewerInconsistency) {
                            results.add('Browser Environment', 'Inconsistent Chrome PDF plugins', 
                                'Plugin arrangement indicates headless environment');
                        }
                    }
                    
                    // Check if user agent changes between checks
                    const userAgentValues = [];
                    for (let i = 0; i < 5; i++) {
                        const currentUA = navigator.userAgent;
                        let isDuplicate = false;
                        
                        for (let j = 0; j < userAgentValues.length; j++) {
                            if (userAgentValues[j] === currentUA) {
                                isDuplicate = true;
                                break;
                            }
                        }
                        
                        if (!isDuplicate) {
                            userAgentValues.push(currentUA);
                        }
                    }
                    
                    if (userAgentValues.length > 1) {
                        results.add('Browser Environment', 'Multiple user agent values detected', 
                            `Found ${userAgentValues.length} different user agent strings`);
                    }
                    
                    // Check if document.elementFromPoint returns null
                    if (document.elementFromPoint(0, 0) === null) {
                        results.add('Browser Environment', 'elementFromPoint returns null', 
                            'This is common in headless browsers');
                    }
                }
            };
            
            // Feature Anomaly Checks
            const featureAnomalyChecks = {
                run: function() {
                    // Check for disabled BigInt support
                    try {
                        if (typeof BigInt === 'function') {
                            const testBigInt = eval('typeof 1n === "bigint" && BigInt(1) === 1n && Number(1n) === 1');
                            if (!testBigInt) {
                                results.add('Feature Anomalies', 'BigInt disabled', 
                                    'BigInt is recognized but does not work properly');
                            }
                        }
                    } catch (e) {
                        results.add('Feature Anomalies', 'BigInt evaluation error', e.message);
                    }
                    
                    // Check for disabled arrow functions
                    try {
                        const testArrow = eval("()=>!!1")();
                        if (!testArrow) {
                            results.add('Feature Anomalies', 'Arrow functions disabled', 
                                'Arrow functions are recognized but do not work properly');
                        }
                    } catch (e) {
                        results.add('Feature Anomalies', 'Arrow function evaluation error', e.message);
                    }
                    
                    // Check for invalid MimeType toString
                    try {
                        const mimeTypeListString = navigator.mimeTypes && navigator.mimeTypes.toString();
                        if (mimeTypeListString !== "[object MimeTypeArray]" && 
                            !/MSMimeTypesCollection/i.test(mimeTypeListString)) {
                            results.add('Feature Anomalies', 'Invalid MimeType array', 
                                `toString returns: ${mimeTypeListString}`);
                        }
                    } catch (e) {
                        // Ignore errors
                    }
                    
                    // Check for modified Date methods
                    const date = new Date();
                    if (utils.isMethodNonNative(date.getTimezoneOffset)) {
                        results.add('Feature Anomalies', 'Modified Date.getTimezoneOffset method', 
                            'This method has been overridden');
                    }
                    
                    // Check for invalid window innerWidth type
                    const innerWidth = window.innerWidth;
                    if (typeof innerWidth !== "number") {
                        results.add('Feature Anomalies', 'Non-numeric window.innerWidth', 
                            `Type: ${typeof innerWidth}, Value: ${innerWidth}`);
                    }
                    
                    // Check for browser features list inconsistencies
                    const featureChecks = [
                        { feature: 'help', object: window },
                        { feature: 'msLaunchUri', object: navigator },
                        { feature: 'sidebar', object: window },
                        { feature: 'ActiveXObject', object: window },
                        { feature: 'IndexedDB', object: window },
                        { feature: 'WebSocket', object: window },
                        { feature: 'VRDisplay', object: window },
                        { feature: 'BluetoothDevice', object: window }
                    ];
                    
                    let featureInconsistencies = [];
                    
                    for (const check of featureChecks) {
                        try {
                            const hasFeature = check.feature in check.object;
                            // Look for anomalies - features missing in Chrome but present, etc.
                            // This is a simplified check - a real implementation would be more sophisticated
                            if ((navigator.userAgent.includes('Chrome') && check.feature === 'sidebar' && hasFeature) ||
                                (navigator.userAgent.includes('Firefox') && check.feature === 'ActiveXObject' && hasFeature)) {
                                featureInconsistencies.push(check.feature);
                            }
                        } catch (e) {
                            // Ignore errors
                        }
                    }
                    
                    if (featureInconsistencies.length) {
                        results.add('Feature Anomalies', 'Browser feature inconsistencies', 
                            `Inconsistent features: ${featureInconsistencies.join(', ')}`);
                    }
                }
            };
            
            // DOM and Event Anomaly Checks
            const domAnomalyChecks = {
                run: function() {
                    // Check for overridden DOM methods
                    const checkDomMethod = (object, methodName) => {
                        try {
                            const method = object.prototype[methodName];
                            if (method && utils.isMethodNonNative(method)) {
                                results.add('DOM Anomalies', `Modified ${object.name}.${methodName}`, 
                                    'This method has been overridden');
                            }
                        } catch (e) {
                            // Ignore errors
                        }
                    };
                    
                    // Check common DOM methods
                    checkDomMethod(HTMLElement, 'getBoundingClientRect');
                    checkDomMethod(HTMLElement, 'getClientRects');
                    checkDomMethod(Document, 'createElement');
                    checkDomMethod(Document, 'querySelector');
                    checkDomMethod(Document, 'querySelectorAll');
                    checkDomMethod(Document, 'evaluate');
                    
                    // Check for iframe contentWindow descriptor modifications
                    try {
                        const iframeDescriptor = utils.getPropertyDescriptor(HTMLIFrameElement.prototype, 'contentWindow');
                        if (iframeDescriptor && iframeDescriptor.get && utils.isMethodNonNative(iframeDescriptor.get)) {
                            results.add('DOM Anomalies', 'Modified iframe.contentWindow getter', 
                                'The getter for contentWindow has been overridden');
                        }
                    } catch (e) {
                        // Ignore errors
                    }
                    
                    // Check for document cookie descriptor modifications
                    try {
                        const cookieDescriptor = utils.getPropertyDescriptor(Document.prototype, 'cookie');
                        if (cookieDescriptor && 
                            ((cookieDescriptor.get && utils.isMethodNonNative(cookieDescriptor.get)) || 
                             (cookieDescriptor.set && utils.isMethodNonNative(cookieDescriptor.set)))) {
                            results.add('DOM Anomalies', 'Modified document.cookie accessors', 
                                'The getter or setter for cookie has been overridden');
                        }
                    } catch (e) {
                        // Ignore errors
                    }
                    
                    // Check for WebGL getParameter method overrides
                    try {
                        const canvas = document.createElement('canvas');
                        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                        
                        if (gl && utils.isMethodNonNative(gl.getParameter)) {
                            results.add('DOM Anomalies', 'Modified WebGL.getParameter method', 
                                'This method has been overridden, commonly done to prevent fingerprinting');
                        }
                    } catch (e) {
                        // Ignore errors
                    }
                    
                    // Check for Navigator prototype modifications
                    if (Object.getPrototypeOf(navigator) !== Navigator.prototype) {
                        results.add('DOM Anomalies', 'Modified Navigator prototype', 
                            'The prototype chain for Navigator has been altered');
                    }
                    
                    // Check for automated stack trace signatures
                    try {
                        // Trigger an error to get stack trace
                        try { null[0](); } catch (error) {
                            // Check for automation patterns in stack trace
                            const stackTrace = error.stack || '';
                            const automationPatterns = [
                                'at callFunction (<anonymous',
                                'at UserScript:Scraper',
                                'evaluateJavascriptFunction',
                                'evaluation_script',
                                'apply.navigator',
                                'at fn (eval at evalFunc)',
                                'eval at evaluate',
                                'utilityscript.evaluate',
                                'pptr.evaluate'
                            ];
                            
                            for (const pattern of automationPatterns) {
                                if (utils.stringContains(stackTrace, pattern)) {
                                    results.add('DOM Anomalies', 'Automation stack trace pattern', 
                                        `Found pattern: ${pattern}`);
                                    break;
                                }
                            }
                        }
                    } catch (e) {
                        // Ignore errors
                    }
                    
                    // Check for non-trusted clicks and events
                    const monitorTrust = (event) => {
                        if (event.isTrusted === false) {
                            results.add('DOM Anomalies', 'Non-trusted event detected', 
                                `Event type: ${event.type}`);
                            document.removeEventListener(event.type, monitorTrust);
                        }
                    };
                    
                    document.addEventListener('click', monitorTrust);
                    document.addEventListener('mousemove', monitorTrust);
                    document.addEventListener('keydown', monitorTrust);
                }
            };
            
            // VM and Sandbox Detection
            const vmSandboxChecks = {
                run: function() {
                    // Check for VM backdoor
                    const vmProperty = 'vm';
                    if (window[vmProperty] && typeof window[vmProperty] === 'object') {
                        const vmProps = Object.keys(window[vmProperty]).slice(0, 10).join(',');
                        results.add('VM/Sandbox', 'VM backdoor detected', 
                            `Found VM properties: ${vmProps}`);
                    }
                    
                    // Check for Chrome DevTools Protocol artifacts
                    const hasChromeProps = !!window.chrome;
                    const hasRuntimeProps = hasChromeProps && !!window.chrome.runtime;
                    
                    if (hasRuntimeProps && window.chrome.runtime.id) {
                        results.add('VM/Sandbox', 'Chrome extension environment detected', 
                            `Extension ID: ${window.chrome.runtime.id}`);
                    }
                    
                    // Check for certain debugging hooks
                    if (typeof window.__REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' || 
                        typeof window.__REDUX_DEVTOOLS_EXTENSION__ !== 'undefined') {
                        results.add('VM/Sandbox', 'Development tools hooks detected', 
                            'Found React/Redux devtools hooks');
                    }
                    
                    // Try to detect Node.js environment
                    if ((typeof process !== 'undefined' && process.versions && process.versions.node) || 
                        typeof global !== 'undefined' || 
                        typeof module !== 'undefined' && module.exports) {
                        results.add('VM/Sandbox', 'Node.js environment detected', 
                            'Found Node.js runtime indicators');
                    }
                    
                    // Detect Cypress test runner
                    if (typeof window.Cypress === 'object' && typeof window.Cypress.isCy === 'function') {
                        results.add('VM/Sandbox', 'Cypress test runner detected', 
                            'Found Cypress automation framework');
                    }
                    
                    // Detect if localStorage is disabled (common in containers)
                    try {
                        const testKey = "_automation_check";
                        window.localStorage.setItem(testKey, testKey);
                        window.localStorage.removeItem(testKey);
                    } catch (e) {
                        results.add('VM/Sandbox', 'localStorage disabled', 
                            'localStorage is not available: ' + e.message);
                    }
                    
                    // Check for bound browser APIs (often happens in WebDriver)
                    const isBoundFunction = (func) => {
                        return func && func.name && !!func.name.match("bound ");
                    };
                    
                    if (isBoundFunction(navigator.getUserMedia) || isBoundFunction(navigator.getBattery)) {
                        results.add('VM/Sandbox', 'Bound browser APIs detected', 
                            'Navigator methods appear to be bound functions');
                    }
                }
            };
            
            // Execute all checks
            const runAllChecks = () => {
                // Clear the results container
                document.getElementById('results').innerHTML = '';
                
                // Run all detection modules
                webDriverChecks.run();
                automationFrameworkChecks.run();
                browserEnvironmentChecks.run();
                featureAnomalyChecks.run();
                domAnomalyChecks.run();
                vmSandboxChecks.run();
                
                // If no detections, show all clear
                setTimeout(() => {
                    if (results.detections.length === 0) {
                        document.getElementById('results').innerHTML = '<p class="no-detection">No automation detected.</p>';
                        document.getElementById('status').textContent = 'Detection completed. No automation indicators found.';
                    }
                }, 1000);
            };
            
            // Run checks when page is loaded
            if (document.readyState === 'complete') {
                runAllChecks();
            } else {
                window.addEventListener('load', runAllChecks);
            }
        })();
    </script>
</body>
</html>
