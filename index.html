<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Browser Automation Detection</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #333;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }
        
        .results {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #f9f9f9;
            min-height: 200px;
            max-height: 500px;
            overflow-y: auto;
        }
        
        .detection {
            margin-bottom: 10px;
            padding: 8px;
            border-left: 4px solid #ff6b6b;
            background-color: #fff0f0;
        }
        
        .no-detection {
            color: #2e7d32;
            font-weight: bold;
        }
        
        .timestamp {
            color: #888;
            font-size: 0.8em;
            margin-top: 4px;
        }
        
        .info-box {
            background-color: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 10px 15px;
            margin: 15px 0;
            border-radius: 4px;
        }
        
        .info-box h3 {
            margin-top: 0;
            color: #0d47a1;
        }

        .category {
            margin-top: 15px;
            font-weight: bold;
            color: #333;
        }
        
        #status {
            font-weight: bold;
            color: #555;
            margin-bottom: 10px;
        }
        
        .progress-bar {
            height: 4px;
            background-color: #e0e0e0;
            border-radius: 2px;
            margin-bottom: 20px;
            overflow: hidden;
        }
        
        .progress-bar-inner {
            height: 100%;
            width: 0%;
            background-color: #2196f3;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Browser Automation Detection</h1>
        <p>This page runs various detection techniques to identify browser automation frameworks like Selenium, Puppeteer, Playwright, and others.</p>
        <div id="status">Running detection checks...</div>
        <div class="progress-bar">
            <div id="progress" class="progress-bar-inner"></div>
        </div>
        <div class="info-box">
            <h3>About This Tool</h3>
            <p>This detector is designed to detect <strong>actual automation tools</strong>, not normal browser features. The script has been calibrated to minimize false positives in standard browser environments.</p>
            <p>Some browsers may naturally have properties that resemble automation tools, but these are not included in our detection algorithm.</p>
        </div>
        <div id="results" class="results">
            <p>Detection results will appear here...</p>
        </div>
    </div>

    <script>
    /**
     * BotDetector - A comprehensive system for detecting bots, automation tools, and fraud
     * This implementation is based on deobfuscated code from a professional anti-bot system
     */
    const BotDetector = (function() {
        'use strict';

        // Main detection report object
        const detectionResults = {
            browserEnvironment: {},
            jsEnvironment: {},
            botFrameworks: {},
            browserBehavior: {},
            fingerprinting: {},
            hardware: {},
            apiManipulation: {},
            deception: {}
        };
        
        // Utility functions
        const utils = {
            hashString: function(str) {
                let hash = 2166136261;
                for (let i = 0; i < str.length; i++) {
                    hash ^= str.charCodeAt(i);
                    hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
                }
                return hash >>> 0;
            },
            
            isMethodNonNative: function(method) {
                const methodString = Function.prototype.toString.call(method);
                return !methodString.includes('[native code]');
            },
            
            getNonNativeMethodString: function(method, maxLength = 1024) {
                try {
                    return Function.prototype.toString.call(method)
                        .replace(/^function\s*\(\)\s*\{/, '')
                        .substring(0, maxLength);
                } catch (error) {
                    return '';
                }
            },
            
            getStackTrace: function() {
                try {
                    throw new Error();
                } catch (error) {
                    return error.stack || '';
                }
            }
        };
        
        //===============================================================
        // 1. Browser Environment Detection
        //===============================================================
        
        const browserEnvironment = {
            detectWebGL: function() {
                try {
                    const canvas = document.createElement('canvas');
                    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    
                    if (!gl) {
                        return { webGLAvailable: false };
                    }
                    
                    const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                    if (!debugInfo) {
                        return { webGLAvailable: true, debugInfoAvailable: false };
                    }
                    
                    const vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
                    const renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                    const shadingLanguageVersion = gl.getParameter(gl.SHADING_LANGUAGE_VERSION);
                    const webglVersion = gl.getParameter(gl.VERSION);
                    const vendorName = gl.getParameter(gl.VENDOR);
                    const rendererName = gl.getParameter(gl.RENDERER);
                    
                    const extensions = gl.getSupportedExtensions();
                    const extensionsHash = extensions ? utils.hashString(extensions.join(',')) : '';
                    
                    detectionResults.browserEnvironment.webGL = {
                        vendor: vendor?.toLowerCase(),
                        renderer: renderer?.toLowerCase(),
                        shadingLanguageVersion: shadingLanguageVersion?.toLowerCase(),
                        webglVersion: webglVersion?.toLowerCase(),
                        vendorName: vendorName?.toLowerCase(),
                        rendererName: rendererName?.toLowerCase(),
                        extensionsHash: extensionsHash
                    };
                    
                    return detectionResults.browserEnvironment.webGL;
                } catch (error) {
                    return { error: error.message };
                }
            },
            
            getBrowserChrome: function() {
                const chromeFeatures = [];
                const uiElements = ['locationbar', 'menubar', 'personalbar', 'scrollbars', 'statusbar', 'toolbar'];
                let hasNonStandardChrome = false;
                
                for (let i = 0; i < uiElements.length; i++) {
                    const element = window[uiElements[i]];
                    const visibility = element && typeof element.visible === 'boolean' ? 
                        +element.visible : '-';
                    
                    if (visibility !== 1) {
                        hasNonStandardChrome = true;
                    }
                    
                    chromeFeatures.push(visibility);
                }
                
                detectionResults.browserEnvironment.chrome = {
                    features: chromeFeatures,
                    nonStandard: hasNonStandardChrome
                };
                
                return detectionResults.browserEnvironment.chrome;
            },
            
            detectScreenAnomalies: function() {
                const screenObj = window.screen;
                
                const hasZeroScreenSize = screenObj.width <= 1 || screenObj.height <= 1;
                const hasZeroAvailableScreenSize = screenObj.availHeight <= 1 || screenObj.availWidth <= 1;
                const hasSmallColorDepth = screenObj.colorDepth <= 8 || screenObj.pixelDepth <= 8 || window.devicePixelRatio <= 0;
                
                detectionResults.browserEnvironment.screen = {
                    zeroSize: hasZeroScreenSize,
                    zeroAvailableSize: hasZeroAvailableScreenSize,
                    smallColorDepth: hasSmallColorDepth,
                    width: screenObj.width,
                    height: screenObj.height,
                    availWidth: screenObj.availWidth,
                    availHeight: screenObj.availHeight,
                    colorDepth: screenObj.colorDepth,
                    pixelDepth: screenObj.pixelDepth,
                    devicePixelRatio: window.devicePixelRatio
                };
                
                return detectionResults.browserEnvironment.screen;
            }
        };
        
        //===============================================================
        // 2. JavaScript Environment Analysis
        //===============================================================
        
        const jsEnvironment = {
            detectNativeFunctionTampering: function() {
                const results = {};
                
                const functionPairs = [
                    ['Document.prototype.createElement', Document.prototype.createElement],
                    ['HTMLElement.prototype.getBoundingClientRect', HTMLElement.prototype.getBoundingClientRect],
                    ['navigator.userAgent getter', Object.getOwnPropertyDescriptor(Navigator.prototype, 'userAgent')?.get],
                    ['Date.prototype.getTimezoneOffset', Date.prototype.getTimezoneOffset]
                ];
                
                for (const [name, func] of functionPairs) {
                    if (func) {
                        const isNonNative = utils.isMethodNonNative(func);
                        results[name] = {
                            isModified: isNonNative
                        };
                        
                        if (isNonNative) {
                            results[name].methodBody = utils.getNonNativeMethodString(func);
                        }
                    }
                }
                
                detectionResults.jsEnvironment.nativeFunctionTampering = results;
                return results;
            },
            
            analyzeStackTrace: function() {
                try {
                    document.createElement('-');
                } catch (error) {
                    const stack = error.stack || '';
                    
                    const patterns = [
                        'at callFunction', 
                        'userscript', 
                        'evaluateJavascriptFunction',
                        'evaluation_script',
                        'apply.navigator',
                        'fn (eval at evalFunc)',
                        'eval at evaluate',
                        'utilityscript.evaluate',
                        'pptr.evaluate'
                    ];
                    
                    const detectedPatterns = patterns.filter(pattern => 
                        stack.toLowerCase().includes(pattern.toLowerCase())
                    );
                    
                    detectionResults.jsEnvironment.stackTrace = {
                        suspicious: detectedPatterns.length > 0,
                        detectedPatterns: detectedPatterns,
                        stackSample: stack.substring(0, 256)
                    };
                    
                    return detectionResults.jsEnvironment.stackTrace;
                }
            },
            
            getMathPrecisionTest: function() {
                try {
                    const testPI = Number('3.141592653589793');
                    
                    const checkFirst = eval(testPI + ' ** -100') == +'1.9275814160560204e-50';
                    const checkSecond = eval(testPI + ' ** -100') == +'1.9275814160560185e-50';
                    const checkThird = eval(testPI + ' ** -100') == +'1.9275814160560206e-50';
                    
                    detectionResults.jsEnvironment.mathPrecision = {
                        checkFirst,
                        checkSecond,
                        checkThird,
                        result: '' + +checkFirst + +checkSecond + +checkThird
                    };
                    
                    return detectionResults.jsEnvironment.mathPrecision;
                } catch (error) {
                    return { error: error.message };
                }
            }
        };
        
        //===============================================================
        // 3. Bot Framework Detection
        //===============================================================
        
        const botFramework = {
            detectAutomationGlobals: function() {
                const automationGlobals = [
                    '_phantom',
                    '__nightmare',
                    '_selenium',
                    'callPhantom',
                    'callSelenium',
                    '_Selenium_IDE_Recorder',
                    'domAutomation',
                    'domAutomationController',
                    '_WEBDRIVER_ELEM_CACHE',
                    'wptagentGetInteractivePeriods',
                    'fSCInitialize',
                    '__webdriverFunc',
                    'geb',
                    'awesomium',
                    '$chrome_asyncScriptInfo',
                    'webdriver',
                    '__webdriverFunc',
                    '_WEBDRIVER_ELEM_CACHE',
                    '$cdc_asdjflasutopfhvcZLmcfl_'
                ];
                
                const detectedGlobals = automationGlobals.filter(name => {
                    try {
                        return window[name] !== undefined;
                    } catch (e) {
                        return false;
                    }
                });
                
                detectionResults.botFrameworks.globals = {
                    detected: detectedGlobals.length > 0,
                    detectedGlobals
                };
                
                return detectionResults.botFrameworks.globals;
            },
            
            detectWebdriverProperties: function() {
                let results = {
                    navigatorHasWebdriver: false,
                    documentHasWebdriverAttributes: false
                };
                
                try {
                    if ('webdriver' in navigator) {
                        results.navigatorHasWebdriver = true;
                        results.webdriverValue = navigator.webdriver;
                    }
                } catch (e) {}
                
                try {
                    const docElement = document.documentElement;
                    const seleniumAttr = docElement.getAttribute('selenium');
                    const webdriverAttr = docElement.getAttribute('webdriver');
                    const driverAttr = docElement.getAttribute('driver');
                    const cdcAttr = docElement.getAttribute('cd_frame_id_');
                    
                    results.documentHasWebdriverAttributes = !!(seleniumAttr || webdriverAttr || driverAttr || cdcAttr);
                    
                    if (results.documentHasWebdriverAttributes) {
                        results.attributes = {
                            selenium: !!seleniumAttr,
                            webdriver: !!webdriverAttr,
                            driver: !!driverAttr,
                            cd_frame_id_: !!cdcAttr
                        };
                    }
                } catch (e) {}
                
                try {
                    const navProto = Object.getPrototypeOf(navigator);
                    const webdriverPropDesc = Object.getOwnPropertyDescriptor(navProto, 'webdriver');
                    
                    if (webdriverPropDesc) {
                        results.hasWebdriverPropertyDescriptor = true;
                        
                        if (webdriverPropDesc.get && utils.isMethodNonNative(webdriverPropDesc.get)) {
                            results.webdriverGetterModified = true;
                            results.webdriverGetterBody = utils.getNonNativeMethodString(webdriverPropDesc.get);
                        }
                    }
                } catch (e) {}
                
                detectionResults.botFrameworks.webdriver = results;
                return results;
            },
            
            detectAutomationExtensions: function() {
                const results = {
                    hasChromeExtension: false,
                    hasPrototypeInRuntimeSendMessage: false
                };
                
                if (window.chrome && !!window.chrome.extension) {
                    results.hasChromeExtension = true;
                }
                
                try {
                    if (window.chrome && window.chrome.runtime && window.chrome.runtime.sendMessage) {
                        results.hasPrototypeInRuntimeSendMessage = !!window.chrome.runtime.sendMessage.prototype;
                    }
                } catch (e) {}
                
                detectionResults.botFrameworks.extensions = results;
                return results;
            }
        };
        
        //===============================================================
        // 4. Browser Behavior Analysis
        //===============================================================
        
        const browserBehavior = {
            initMouseMonitoring: function() {
                const state = {
                    movements: [],
                    clicks: [],
                    firstMovementTime: null,
                    firstClickTime: null
                };
                
                const recordMousePosition = function(event, type) {
                    const timestamp = Date.now();
                    const isTrusted = event.isTrusted !== false;
                    
                    const position = {
                        clientX: event.clientX,
                        clientY: event.clientY,
                        pageX: event.pageX,
                        pageY: event.pageY,
                        screenX: event.screenX,
                        screenY: event.screenY,
                        timestamp: timestamp,
                        isTrusted: isTrusted
                    };
                    
                    if (type === 'movement') {
                        if (!state.firstMovementTime) {
                            state.firstMovementTime = timestamp;
                        }
                        state.movements.push(position);
                        
                        if (state.movements.length > 20) {
                            state.movements.shift();
                        }
                    } else if (type === 'click') {
                        if (!state.firstClickTime) {
                            state.firstClickTime = timestamp;
                        }
                        
                        try {
                            const element = event.target;
                            if (element) {
                                position.element = {
                                    tagName: element.tagName.toLowerCase(),
                                    id: element.id,
                                    className: element.className
                                };
                                
                                position.isInteractive = 
                                    ['button', 'a', 'input', 'select', 'textarea'].includes(position.element.tagName) ||
                                    typeof element.onclick === 'function';
                            }
                        } catch (e) {}
                        
                        state.clicks.push(position);
                        
                        if (state.clicks.length > 10) {
                            state.clicks.shift();
                        }
                    }
                    
                    detectionResults.browserBehavior.mouse = state;
                };
                
                document.addEventListener('mousemove', e => recordMousePosition(e, 'movement'));
                document.addEventListener('click', e => recordMousePosition(e, 'click'));
                
                return {
                    getState: () => state
                };
            },
            
            initKeyboardMonitoring: function() {
                const state = {
                    events: [],
                    firstEventTime: null,
                    uniqueKeysPressed: new Set()
                };
                
                const recordKeyEvent = function(event) {
                    const timestamp = Date.now();
                    
                    if (!state.firstEventTime) {
                        state.firstEventTime = timestamp;
                    }
                    
                    const keyEvent = {
                        type: event.type,
                        key: event.key,
                        code: event.code,
                        keyCode: event.keyCode,
                        isTrusted: event.isTrusted !== false,
                        timestamp: timestamp
                    };
                    
                    state.events.push(keyEvent);
                    state.uniqueKeysPressed.add(event.key);
                    
                    if (state.events.length > 20) {
                        state.events.shift();
                    }
                    
                    detectionResults.browserBehavior.keyboard = {
                        events: state.events,
                        firstEventTime: state.firstEventTime,
                        uniqueKeysCount: state.uniqueKeysPressed.size
                    };
                };
                
                document.addEventListener('keydown', recordKeyEvent);
                document.addEventListener('keyup', recordKeyEvent);
                
                return {
                    getState: () => detectionResults.browserBehavior.keyboard
                };
            },
            
            initVisibilityMonitoring: function() {
                const state = {
                    changes: [],
                    currentState: document.visibilityState
                };
                
                const recordVisibilityChange = function() {
                    const timestamp = Date.now();
                    const visibilityState = document.visibilityState;
                    
                    state.changes.push({
                        timestamp: timestamp,
                        state: visibilityState
                    });
                    
                    state.currentState = visibilityState;
                    
                    if (state.changes.length > 10) {
                        state.changes.shift();
                    }
                    
                    detectionResults.browserBehavior.visibility = state;
                };
                
                recordVisibilityChange();
                
                document.addEventListener('visibilitychange', recordVisibilityChange);
                
                return {
                    getState: () => state
                };
            }
        };
        
        //===============================================================
        // 5. Advanced Fingerprinting
        //===============================================================
        
        const fingerprinting = {
            getCanvasFingerprint: function() {
                try {
                    const canvas = document.createElement('canvas');
                    canvas.width = 400;
                    canvas.height = 60;
                    
                    const context = canvas.getContext('2d');
                    
                    context.fillStyle = '#f60';
                    context.fillRect(125, 1, 62, 20);
                    
                    context.fillStyle = '#069';
                    context.font = '11pt Arial';
                    context.fillText('Cwm fjordbank glyphs vext quiz, ðŸ˜ƒ', 2, 15);
                    
                    context.fillStyle = 'rgba(102, 204, 0, 0.7)';
                    context.font = '18pt Arial';
                    context.fillText('Cwm fjordbank glyphs vext quiz, ðŸ˜ƒ', 4, 45);
                    
                    const fingerprint = canvas.toDataURL();
                    const hash = utils.hashString(fingerprint);
                    
                    detectionResults.fingerprinting.canvas = {
                        hash: hash,
                        sampleLength: fingerprint.length
                    };
                    
                    return detectionResults.fingerprinting.canvas;
                } catch (error) {
                    return { error: error.message };
                }
            },
            
            getAudioFingerprint: function() {
                try {
                    const audioContext = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(1, 5000, 44100);
                    
                    const analyser = audioContext.createAnalyser();
                    const oscillator = audioContext.createOscillator();
                    const dynamicsCompressor = audioContext.createDynamicsCompressor();
                    
                    oscillator.type = 'triangle';
                    oscillator.frequency.value = 10000;
                    
                    dynamicsCompressor.threshold.value = -50;
                    dynamicsCompressor.knee.value = 40;
                    dynamicsCompressor.attack.value = 0;
                    
                    oscillator.connect(dynamicsCompressor);
                    dynamicsCompressor.connect(analyser);
                    dynamicsCompressor.connect(audioContext.destination);
                    
                    oscillator.start(0);
                    audioContext.startRendering();
                    
                    const audioData = [];
                    
                    audioContext.oncomplete = function(event) {
                        const samples = event.renderedBuffer.getChannelData(0);
                        
                        for (let i = 0; i < 20; i++) {
                            const index = Math.floor(samples.length / 20 * i);
                            audioData.push(samples[index]);
                        }
                        
                        const hash = utils.hashString(audioData.join(''));
                        
                        detectionResults.fingerprinting.audio = {
                            hash: hash,
                            sampleCount: audioData.length
                        };
                    };
                    
                    return { started: true };
                } catch (error) {
                    return { error: error.message };
                }
            },
            
            getFontDetection: function() {
                const baseFonts = ['monospace', 'sans-serif', 'serif'];
                const fontList = [
                    'Arial', 'Courier New', 'Georgia', 'Times New Roman', 'Verdana',
                    'Helvetica', 'Tahoma', 'Trebuchet MS', 'Geneva', 'Cambria',
                    'Garamond', 'Palatino', 'Roboto', 'Segoe UI', 'Ubuntu',
                    'DejaVu Sans', 'Liberation Sans'
                ];
                
                const testString = 'mmmmmmmmmmlli';
                const testSize = '72px';
                const h = document.getElementsByTagName('body')[0];
                
                const s = document.createElement('span');
                s.style.fontSize = testSize;
                s.innerHTML = testString;
                
                const defaultWidth = {};
                const defaultHeight = {};
                
                for (let index in baseFonts) {
                    s.style.fontFamily = baseFonts[index];
                    h.appendChild(s);
                    defaultWidth[baseFonts[index]] = s.offsetWidth;
                    defaultHeight[baseFonts[index]] = s.offsetHeight;
                    h.removeChild(s);
                }
                
                const detected = [];
                
                for (let i = 0; i < fontList.length; i++) {
                    let isDetected = false;
                    
                    for (let j = 0; j < baseFonts.length; j++) {
                        s.style.fontFamily = fontList[i] + ',' + baseFonts[j];
                        h.appendChild(s);
                        
                        const matched = 
                            s.offsetWidth !== defaultWidth[baseFonts[j]] || 
                            s.offsetHeight !== defaultHeight[baseFonts[j]];
                        
                        h.removeChild(s);
                        
                        if (matched) {
                            isDetected = true;
                            break;
                        }
                    }
                    
                    if (isDetected) {
                        detected.push(fontList[i]);
                    }
                }
                
                detectionResults.fingerprinting.fonts = {
                    detectedFonts: detected,
                    detectedCount: detected.length
                };
                
                return detectionResults.fingerprinting.fonts;
            }
        };
        
        //===============================================================
        // 6. Hardware and Device Detection
        //===============================================================
        
        const hardware = {
            getMediaDevices: function() {
                return new Promise((resolve) => {
                    if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
                        detectionResults.hardware.mediaDevices = {
                            available: false
                        };
                        resolve(detectionResults.hardware.mediaDevices);
                        return;
                    }
                    
                    navigator.mediaDevices.enumerateDevices()
                        .then(devices => {
                            const counts = {
                                audioInput: 0,
                                audioOutput: 0,
                                videoInput: 0
                            };
                            
                            devices.forEach(device => {
                                switch (device.kind) {
                                    case 'audioinput':
                                        counts.audioInput++;
                                        break;
                                    case 'audiooutput':
                                        counts.audioOutput++;
                                        break;
                                    case 'videoinput':
                                        counts.videoInput++;
                                        break;
                                }
                            });
                            
                            detectionResults.hardware.mediaDevices = {
                                available: true,
                                counts: counts,
                                total: devices.length
                            };
                            
                            resolve(detectionResults.hardware.mediaDevices);
                        })
                        .catch(error => {
                            detectionResults.hardware.mediaDevices = {
                                available: true,
                                error: error.message
                            };
                            resolve(detectionResults.hardware.mediaDevices);
                        });
                });
            },
            
            getCPUAndMemoryInfo: function() {
                const results = {
                    hardwareConcurrency: navigator.hardwareConcurrency,
                    deviceMemory: navigator.deviceMemory
                };
                
                results.suspiciousHardwareConcurrency = 
                    navigator.hardwareConcurrency === undefined || 
                    navigator.hardwareConcurrency <= 1;
                    
                results.suspiciousDeviceMemory = 
                    navigator.deviceMemory === undefined || 
                    navigator.deviceMemory <= 1;
                
                detectionResults.hardware.cpuMemory = results;
                return results;
            },
            
            detectVMEnvironment: function() {
                const results = {
                    isVM: false,
                    indicators: []
                };
                
                if (window.vmware && typeof window.vmware === 'object') {
                    results.isVM = true;
                    results.indicators.push('vmware object present');
                }
                
                if (window.VirtualBox && typeof window.VirtualBox === 'object') {
                    results.isVM = true;
                    results.indicators.push('VirtualBox object present');
                }
                
                const vmProps = ['vboxrt', 'vboxdtcc'];
                for (const prop of vmProps) {
                    if (window[prop] !== undefined) {
                        results.isVM = true;
                        results.indicators.push(`${prop} property present`);
                    }
                }
                
                detectionResults.hardware.vm = results;
                return results;
            }
        };
        
        //===============================================================
        // 7. Browser API Manipulation Detection
        //===============================================================
        
        const apiManipulation = {
            detectNavigatorManipulation: function() {
                const results = {
                    modified: false,
                    modifiedProperties: []
                };
                
                const propsToCheck = [
                    'userAgent', 'platform', 'vendor', 'appVersion',
                    'language', 'languages', 'plugins', 'mimeTypes'
                ];
                
                for (const prop of propsToCheck) {
                    try {
                        const descriptor = Object.getOwnPropertyDescriptor(Navigator.prototype, prop);
                        
                        if (descriptor && descriptor.get && utils.isMethodNonNative(descriptor.get)) {
                            results.modified = true;
                            results.modifiedProperties.push({
                                property: prop,
                                details: utils.getNonNativeMethodString(descriptor.get, 100)
                            });
                        }
                    } catch (e) {}
                }
                
                detectionResults.apiManipulation.navigator = results;
                return results;
            },
            
            detectPermissionsAPIManipulation: function() {
                const results = {
                    modified: false
                };
                
                try {
                    if (navigator.permissions && navigator.permissions.query) {
                        results.available = true;
                        results.modified = utils.isMethodNonNative(navigator.permissions.query);
                        
                        if (results.modified) {
                            results.methodBody = utils.getNonNativeMethodString(navigator.permissions.query, 100);
                        }
                    } else {
                        results.available = false;
                    }
                } catch (e) {
                    results.error = e.message;
                }
                
                detectionResults.apiManipulation.permissions = results;
                return results;
            },
            
            detectContentWindowManipulation: function() {
                const results = {
                    modified: false
                };
                
                try {
                    const iframe = document.createElement('iframe');
                    const iframeProto = Object.getPrototypeOf(iframe);
                    
                    const descriptor = Object.getOwnPropertyDescriptor(iframeProto, 'contentWindow');
                    
                    if (descriptor && descriptor.get) {
                        results.modified = utils.isMethodNonNative(descriptor.get);
                        
                        if (results.modified) {
                            results.methodBody = utils.getNonNativeMethodString(descriptor.get, 100);
                        }
                    }
                } catch (e) {
                    results.error = e.message;
                }
                
                detectionResults.apiManipulation.contentWindow = results;
                return results;
            },
            
            detectTimezoneManipulation: function() {
                const results = {
                    modified: false
                };
                
                try {
                    const date = new Date();
                    results.modified = utils.isMethodNonNative(date.getTimezoneOffset);
                    
                    if (results.modified) {
                        results.methodBody = utils.getNonNativeMethodString(date.getTimezoneOffset, 100);
                    }
                    
                    const timezoneOffset = date.getTimezoneOffset() / 60;
                    
                    let intl;
                    try {
                        intl = Intl.DateTimeFormat().resolvedOptions();
                    } catch (e) {}
                    
                    results.timezoneOffset = timezoneOffset;
                    
                    if (intl) {
                        results.intl = {
                            timeZone: intl.timeZone,
                            locale: intl.locale,
                            calendar: intl.calendar
                        };
                    }
                    
                    if (intl && intl.timeZone) {
                        const tzParts = intl.timeZone.split('/');
                        const tzName = tzParts[tzParts.length - 1].toLowerCase();
                        
                        const westCoastNames = ['los_angeles', 'vancouver', 'tijuana', 'pacific'];
                        const eastCoastNames = ['new_york', 'toronto', 'eastern'];
                        const europeanNames = ['london', 'paris', 'berlin', 'rome', 'amsterdam'];
                        const asianNames = ['tokyo', 'shanghai', 'hong_kong', 'singapore'];
                        
                        let expectedRanges = [];
                        
                        if (westCoastNames.some(name => tzName.includes(name.toLowerCase()))) {
                            expectedRanges = [-8, -7]; // PST/PDT
                        } else if (eastCoastNames.some(name => tzName.includes(name.toLowerCase()))) {
                            expectedRanges = [-5, -4]; // EST/EDT
                        } else if (europeanNames.some(name => tzName.includes(name.toLowerCase()))) {
                            expectedRanges = [0, 1, 2]; // GMT/CET
                        } else if (asianNames.some(name => tzName.includes(name.toLowerCase()))) {
                            expectedRanges = [8, 9]; // CST/JST
                        }
                        
                        if (expectedRanges.length > 0) {
                            results.timezoneConsistent = expectedRanges.includes(Math.round(-timezoneOffset));
                        }
                    }
                } catch (e) {
                    results.error = e.message;
                }
                
                detectionResults.apiManipulation.timezone = results;
                return results;
            }
        };
        
        //===============================================================
        // 8. Deception Detection
        //===============================================================
        
        const deception = {
            createHiddenBaitElements: function() {
                const results = {
                    created: false,
                    interactions: []
                };
                
                try {
                    const hiddenDiv = document.createElement('div');
                    hiddenDiv.style.cssText = 'opacity:0.01 !important; position:absolute !important; z-index:-990 !important; width:54px !important; height:22px !important;';
                    
                    const hiddenLink = document.createElement('a');
                    hiddenLink.innerHTML = '___';
                    hiddenLink.setAttribute('href', '#');
                    hiddenLink.setAttribute('tabindex', '-1');
                    hiddenLink.setAttribute('aria-hidden', 'true');
                    hiddenLink.setAttribute('rel', 'nofollow');
                    hiddenLink.style.cssText = 'opacity:0.01 !important; position:absolute !important; z-index:-991 !important; width:54px !important; height:22px !important;';
                    
                    const interactionHandler = function(event) {
                        event.preventDefault();
                        event.stopPropagation();
                        
                        results.interactions.push({
                            type: event.type,
                            timestamp: Date.now(),
                            isTrusted: event.isTrusted !== false,
                            targetId: event.target.id
                        });
                        
                        detectionResults.deception.baitElements = results;
                    };
                    
                    hiddenDiv.addEventListener('click', interactionHandler);
                    hiddenDiv.addEventListener('mouseover', interactionHandler);
                    hiddenLink.addEventListener('click', interactionHandler);
                    hiddenLink.addEventListener('mouseover', interactionHandler);
                    
                    hiddenDiv.id = 'hb_' + Math.random().toString(36).substring(2, 8);
                    hiddenLink.id = 'hl_' + Math.random().toString(36).substring(2, 8);
                    
                    if (document.body) {
                        document.body.appendChild(hiddenDiv);
                        document.body.appendChild(hiddenLink);
                        results.created = true;
                    } else {
                        document.addEventListener('DOMContentLoaded', function() {
                            document.body.appendChild(hiddenDiv);
                            document.body.appendChild(hiddenLink);
                            results.created = true;
                        });
                    }
                    
                    detectionResults.deception.baitElements = results;
                } catch (e) {
                    results.error = e.message;
                    detectionResults.deception.baitElements = results;
                }
                
                return results;
            },
            
            analyzeEventTrust: function() {
                const state = {
                    events: [],
                    untrustedDetected: false
                };
                
                const recordEvent = function(event) {
                    const eventData = {
                        type: event.type,
                        target: event.target.tagName,
                        timestamp: Date.now(),
                        isTrusted: event.isTrusted !== false
                    };
                    
                    state.events.push(eventData);
                    
                    if (!eventData.isTrusted) {
                        state.untrustedDetected = true;
                    }
                    
                    if (state.events.length > 20) {
                        state.events.shift();
                    }
                    
                    detectionResults.deception.eventTrust = state;
                };
                
                const eventsToMonitor = [
                    'click', 'mousedown', 'mouseup', 'mousemove',
                    'keydown', 'keyup', 'touchstart', 'touchend'
                ];
                
                for (const eventType of eventsToMonitor) {
                    document.addEventListener(eventType, recordEvent, true);
                }
                
                detectionResults.deception.eventTrust = state;
                return state;
            }
        };
        
        //===============================================================
        // Public API
        //===============================================================
        
        // Initialize behavioral monitoring
        const mouseMonitor = browserBehavior.initMouseMonitoring();
        const keyboardMonitor = browserBehavior.initKeyboardMonitoring();
        const visibilityMonitor = browserBehavior.initVisibilityMonitoring();
        
        // Create bait elements
        deception.createHiddenBaitElements();
        
        // Initialize event trust analysis
        deception.analyzeEventTrust();
        
        return {
            runDetection: function() {
                // Browser Environment checks
                browserEnvironment.detectWebGL();
                browserEnvironment.getBrowserChrome();
                browserEnvironment.detectScreenAnomalies();
                
                // JavaScript Environment checks
                jsEnvironment.detectNativeFunctionTampering();
                jsEnvironment.analyzeStackTrace();
                jsEnvironment.getMathPrecisionTest();
                
                // Bot Framework checks
                botFramework.detectAutomationGlobals();
                botFramework.detectWebdriverProperties();
                botFramework.detectAutomationExtensions();
                
                // Advanced fingerprinting
                fingerprinting.getCanvasFingerprint();
                fingerprinting.getAudioFingerprint();
                fingerprinting.getFontDetection();
                
                // Hardware checks
                hardware.getCPUAndMemoryInfo();
                hardware.detectVMEnvironment();
                hardware.getMediaDevices();
                
                // API Manipulation checks
                apiManipulation.detectNavigatorManipulation();
                apiManipulation.detectPermissionsAPIManipulation();
                apiManipulation.detectContentWindowManipulation();
                apiManipulation.detectTimezoneManipulation();
                
                return detectionResults;
            },
            
            getResults: function() {
                return detectionResults;
            },
            
            isLikelyBot: function() {
                this.runDetection();
                
                const botIndicators = [];
                
                // Check browser environment
                if (detectionResults.browserEnvironment.screen && 
                   (detectionResults.browserEnvironment.screen.zeroSize || 
                    detectionResults.browserEnvironment.screen.zeroAvailableSize ||
                    detectionResults.browserEnvironment.screen.smallColorDepth)) {
                    botIndicators.push('Suspicious screen properties');
                }
                
                // Check JS environment
                if (detectionResults.jsEnvironment.nativeFunctionTampering) {
                    const tamperedFunctions = Object.keys(detectionResults.jsEnvironment.nativeFunctionTampering)
                        .filter(key => detectionResults.jsEnvironment.nativeFunctionTampering[key].isModified);
                    
                    if (tamperedFunctions.length > 0) {
                        botIndicators.push('Modified native functions: ' + tamperedFunctions.join(', '));
                    }
                }
                
                // Check for bot frameworks
                if (detectionResults.botFrameworks.globals && detectionResults.botFrameworks.globals.detected) {
                    botIndicators.push('Automation globals detected: ' + 
                        detectionResults.botFrameworks.globals.detectedGlobals.join(', '));
                }
                
                if (detectionResults.botFrameworks.webdriver && 
                   (detectionResults.botFrameworks.webdriver.navigatorHasWebdriver || 
                    detectionResults.botFrameworks.webdriver.documentHasWebdriverAttributes)) {
                    botIndicators.push('WebDriver detected');
                }
                
                // Check for API manipulation
                if (detectionResults.apiManipulation.navigator && 
                    detectionResults.apiManipulation.navigator.modified) {
                    botIndicators.push('Navigator properties modified');
                }
                
                if (detectionResults.apiManipulation.permissions && 
                    detectionResults.apiManipulation.permissions.modified) {
                    botIndicators.push('Permissions API modified');
                }
                
                if (detectionResults.apiManipulation.contentWindow && 
                    detectionResults.apiManipulation.contentWindow.modified) {
                    botIndicators.push('ContentWindow API modified');
                }
                
                if (detectionResults.apiManipulation.timezone && 
                    detectionResults.apiManipulation.timezone.modified) {
                    botIndicators.push('Timezone API modified');
                }
                
                // Check for suspicious hardware/VM
                if (detectionResults.hardware.vm && detectionResults.hardware.vm.isVM) {
                    botIndicators.push('VM environment detected');
                }
                
                // Check for untrusted events
                if (detectionResults.deception.eventTrust && 
                    detectionResults.deception.eventTrust.untrustedDetected) {
                    botIndicators.push('Untrusted events detected');
                }
                
                // Check for bait element interaction
                if (detectionResults.deception.baitElements && 
                    detectionResults.deception.baitElements.interactions.length > 0) {
                    botIndicators.push('Interaction with hidden bait elements');
                }
                
                return {
                    isBot: botIndicators.length > 0,
                    botScore: botIndicators.length,
                    indicators: botIndicators
                };
            }
        };
    })();

    // UI Helper Functions
    function updateProgressBar(percent) {
        const progressBar = document.getElementById('progress');
        progressBar.style.width = percent + '%';
    }

    function updateStatus(message) {
        const statusElement = document.getElementById('status');
        statusElement.textContent = message;
    }

    function addDetection(message, details) {
        const resultsElement = document.getElementById('results');
        
        if (resultsElement.querySelector('p')) {
            resultsElement.innerHTML = '';
        }
        
        const detectionElement = document.createElement('div');
        detectionElement.className = 'detection';
        
        const messageElement = document.createElement('div');
        messageElement.textContent = message;
        detectionElement.appendChild(messageElement);
        
        if (details) {
            const detailsElement = document.createElement('div');
            detailsElement.style.fontSize = '0.9em';
            detailsElement.style.marginTop = '5px';
            detailsElement.style.color = '#555';
            detailsElement.textContent = details;
            detectionElement.appendChild(detailsElement);
        }
        
        const timestampElement = document.createElement('div');
        timestampElement.className = 'timestamp';
        
        const now = new Date();
        const timeString = now.toLocaleTimeString();
        timestampElement.textContent = timeString;
        
        detectionElement.appendChild(timestampElement);
        resultsElement.appendChild(detectionElement);
    }

    function addCategory(name) {
        const resultsElement = document.getElementById('results');
        
        const categoryElement = document.createElement('div');
        categoryElement.className = 'category';
        categoryElement.textContent = name;
        
        resultsElement.appendChild(categoryElement);
    }

    function displayNoBotMessage() {
        const resultsElement = document.getElementById('results');
        
        const noBotElement = document.createElement('div');
        noBotElement.className = 'no-detection';
        noBotElement.textContent = 'No automation tools detected. Your browser appears to be normal.';
        
        resultsElement.appendChild(noBotElement);
    }

    // Run detection in stages to show progressive results
    document.addEventListener('DOMContentLoaded', function() {
        let detectionComplete = false;
        
        // Stage 1: Initial checks
        setTimeout(function() {
            updateStatus('Checking browser environment...');
            updateProgressBar(20);
            
            // Detect screen anomalies
            const screenResults = BotDetector.isLikelyBot();
            if (screenResults.isBot) {
                addCategory('Automation Detection');
                
                screenResults.indicators.forEach(function(indicator) {
                    addDetection(indicator);
                });
            }
        }, 500);
        
        // Stage 2: Framework detection
        setTimeout(function() {
            updateStatus('Checking for automation frameworks...');
            updateProgressBar(40);
            
            const botResults = BotDetector.getResults();
            
            // Check webdriver
            if (botResults.botFrameworks && botResults.botFrameworks.webdriver && 
                (botResults.botFrameworks.webdriver.navigatorHasWebdriver || 
                botResults.botFrameworks.webdriver.documentHasWebdriverAttributes)) {
                
                addCategory('WebDriver Detection');
                
                if (botResults.botFrameworks.webdriver.navigatorHasWebdriver) {
                    addDetection('WebDriver property detected in navigator', 
                        'The navigator.webdriver property is ' + botResults.botFrameworks.webdriver.webdriverValue);
                }
                
                if (botResults.botFrameworks.webdriver.documentHasWebdriverAttributes) {
                    let attrs = [];
                    for (let attr in botResults.botFrameworks.webdriver.attributes) {
                        if (botResults.botFrameworks.webdriver.attributes[attr]) {
                            attrs.push(attr);
                        }
                    }
                    addDetection('WebDriver attributes found in document', 
                        'Attributes: ' + attrs.join(', '));
                }
            }
            
            // Check for automation globals
            if (botResults.botFrameworks && botResults.botFrameworks.globals && 
                botResults.botFrameworks.globals.detected) {
                
                addCategory('Automation Globals');
                
                addDetection('Automation global variables detected', 
                    'Detected: ' + botResults.botFrameworks.globals.detectedGlobals.join(', '));
            }
        }, 1000);
        
        // Stage 3: JavaScript environment
        setTimeout(function() {
            updateStatus('Analyzing JavaScript environment...');
            updateProgressBar(60);
            
            const botResults = BotDetector.getResults();
            
            // Check for tampered functions
            if (botResults.jsEnvironment && botResults.jsEnvironment.nativeFunctionTampering) {
                const tamperedFunctions = Object.keys(botResults.jsEnvironment.nativeFunctionTampering)
                    .filter(key => botResults.jsEnvironment.nativeFunctionTampering[key].isModified);
                
                if (tamperedFunctions.length > 0) {
                    addCategory('Native Function Tampering');
                    
                    tamperedFunctions.forEach(function(funcName) {
                        addDetection('Modified native function: ' + funcName);
                    });
                }
            }
            
            // Check stack trace
            if (botResults.jsEnvironment && botResults.jsEnvironment.stackTrace && 
                botResults.jsEnvironment.stackTrace.suspicious) {
                
                addCategory('Suspicious Stack Trace');
                
                addDetection('Suspicious patterns in stack trace', 
                    'Patterns: ' + botResults.jsEnvironment.stackTrace.detectedPatterns.join(', '));
            }
        }, 1500);
        
        // Stage 4: API manipulation
        setTimeout(function() {
            updateStatus('Checking for API manipulations...');
            updateProgressBar(80);
            
            const botResults = BotDetector.getResults();
            
            // Check for navigator manipulation
            if (botResults.apiManipulation && botResults.apiManipulation.navigator && 
                botResults.apiManipulation.navigator.modified) {
                
                addCategory('API Manipulation');
                
                const modifiedProps = botResults.apiManipulation.navigator.modifiedProperties
                    .map(item => item.property);
                
                addDetection('Navigator properties have been modified', 
                    'Modified: ' + modifiedProps.join(', '));
            }
            
            // Check for permissions API manipulation
            if (botResults.apiManipulation && botResults.apiManipulation.permissions && 
                botResults.apiManipulation.permissions.modified) {
                
                if (!document.querySelector('.category:last-child').textContent.includes('API Manipulation')) {
                    addCategory('API Manipulation');
                }
                
                addDetection('Permissions API has been modified');
            }
            
            // Check for timezone manipulation
            if (botResults.apiManipulation && botResults.apiManipulation.timezone && 
                botResults.apiManipulation.timezone.modified) {
                
                if (!document.querySelector('.category:last-child').textContent.includes('API Manipulation')) {
                    addCategory('API Manipulation');
                }
                
                addDetection('Timezone API has been modified');
            }
        }, 2000);
        
        // Final stage: Complete detection
        setTimeout(function() {
            updateStatus('Detection complete!');
            updateProgressBar(100);
            
            // Get final results
            const finalResults = BotDetector.isLikelyBot();
            
            if (!finalResults.isBot && !detectionComplete) {
                // No detections
                displayNoBotMessage();
            } else if (finalResults.isBot) {
                // Show bot score
                const resultsElement = document.getElementById('results');
                
                const scoreElement = document.createElement('div');
                scoreElement.style.marginTop = '20px';
                scoreElement.style.fontWeight = 'bold';
                scoreElement.textContent = 'Bot Score: ' + finalResults.botScore + ' / 10';
                
                resultsElement.appendChild(scoreElement);
            }
            
            detectionComplete = true;
        }, 2500);
    });
    </script>
</body>
</html>
