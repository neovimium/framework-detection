<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Browser Automation Detection</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #333;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }
        
        .results {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #f9f9f9;
            max-height: 500px;
            overflow-y: auto;
        }
        
        .detection {
            margin-bottom: 10px;
            padding: 8px;
            border-left: 4px solid #ff6b6b;
            background-color: #fff0f0;
        }
        
        .no-detection {
            color: #2e7d32;
            font-weight: bold;
        }
        
        .timestamp {
            color: #888;
            font-size: 0.8em;
            margin-top: 4px;
        }
        
        .info-box {
            background-color: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 10px 15px;
            margin: 15px 0;
            border-radius: 4px;
        }
        
        .info-box h3 {
            margin-top: 0;
            color: #0d47a1;
        }

        .category {
            margin-top: 20px;
            font-weight: bold;
            color: #333;
            padding: 5px;
            background-color: #f0f0f0;
            border-radius: 4px;
        }
        
        .subcategory {
            margin-top: 10px;
            font-weight: bold;
            color: #555;
            padding-left: 5px;
            border-left: 3px solid #2196f3;
        }
        
        .result-item {
            margin: 8px 0 8px 15px;
            padding: 5px;
            background-color: #f8f8f8;
            border-radius: 4px;
        }
        
        .detection-positive {
            background-color: #ffebee;
            border-left: 3px solid #f44336;
        }
        
        .detection-negative {
            background-color: #e8f5e9;
            border-left: 3px solid #4caf50;
        }
        
        .expected {
            font-style: italic;
            color: #666;
            font-size: 0.9em;
            margin-top: 3px;
        }
        
        #status {
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-weight: bold;
            background-color: #fff3cd;
            border: 1px solid #ffeeba;
            color: #856404;
        }
        
        .status-complete {
            background-color: #d4edda !important;
            border-color: #c3e6cb !important;
            color: #155724 !important;
        }
        
        #summary {
            margin-top: 15px;
            padding: 15px;
            background-color: #e8eaf6;
            border-radius: 4px;
            border: 1px solid #c5cae9;
        }
        
        .summary-bot {
            background-color: #ffebee !important;
            border-color: #ffcdd2 !important;
            animation: pulse 2s infinite;
        }
        
        .summary-clean {
            background-color: #e8f5e9 !important;
            border-color: #c8e6c9 !important;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 82, 82, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(255, 82, 82, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 82, 82, 0); }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Browser Automation Detection</h1>
        <p>This page runs various detection techniques to identify browser automation frameworks like Selenium, Puppeteer, Playwright, and others.</p>
        <div id="status">Running detection checks... Please interact with the page (move your mouse, click, type) to improve results.</div>
        <div class="info-box">
            <h3>About This Tool</h3>
            <p>This detector is designed to detect <strong>actual automation tools</strong>, not normal browser features. The script has been calibrated to minimize false positives in standard browser environments.</p>
            <p>Some browsers may naturally have properties that resemble automation tools, but these are not included in our detection algorithm.</p>
        </div>
        <div id="summary" class="summary-clean">
            <h2>Detection Summary</h2>
            <p>Detection in progress... Results will appear here.</p>
        </div>
        <div id="results" class="results">
            <p>Detection results will appear here...</p>
        </div>
    </div>

    <script>
    // Initialize results display immediately
    document.addEventListener('DOMContentLoaded', function() {
        document.getElementById('results').innerHTML = '<p><strong>Running detection tests...</strong><br>This may take a few seconds. Please interact with the page (move mouse, scroll) to improve detection accuracy.</p>';
    });
    
    /**
     * BotDetector - A comprehensive system for detecting bots, automation tools, and fraud
     * This implementation is based on deobfuscated code from a professional anti-bot system
     */
    const BotDetector = (function() {
        'use strict';

        // Main detection report object
        const detectionResults = {
            browserEnvironment: {},
            jsEnvironment: {},
            botFrameworks: {},
            browserBehavior: {},
            fingerprinting: {},
            hardware: {},
            apiManipulation: {},
            deception: {}
        };
        
        // Utility functions
        const utils = {
            /**
             * Hash string - simplified FNV-like hash function
             */
            hashString: function(str) {
                let hash = 2166136261;
                for (let i = 0; i < str.length; i++) {
                    hash ^= str.charCodeAt(i);
                    hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
                }
                return hash >>> 0;
            },
            
            /**
             * Check if method is native or has been tampered with
             */
            isMethodNonNative: function(method) {
                const methodString = Function.prototype.toString.call(method);
                return !methodString.includes('[native code]');
            },
            
            /**
             * Get the full string representation of a non-native method
             */
            getNonNativeMethodString: function(method, maxLength = 1024) {
                try {
                    return Function.prototype.toString.call(method)
                        .replace(/^function\s*\(\)\s*\{/, '')
                        .substring(0, maxLength);
                } catch (error) {
                    return '';
                }
            },
            
            /**
             * Get error stack trace for analysis
             */
            getStackTrace: function() {
                try {
                    throw new Error();
                } catch (error) {
                    return error.stack || '';
                }
            }
        };
        
        //===============================================================
        // 1. Browser Environment Detection
        //===============================================================
        
        const browserEnvironment = {
            /**
             * Detect WebGL fingerprinting data
             */
            detectWebGL: function() {
                try {
                    const canvas = document.createElement('canvas');
                    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    
                    if (!gl) {
                        return { webGLAvailable: false };
                    }
                    
                    const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                    if (!debugInfo) {
                        return { webGLAvailable: true, debugInfoAvailable: false };
                    }
                    
                    const vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
                    const renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                    const shadingLanguageVersion = gl.getParameter(gl.SHADING_LANGUAGE_VERSION);
                    const webglVersion = gl.getParameter(gl.VERSION);
                    const vendorName = gl.getParameter(gl.VENDOR);
                    const rendererName = gl.getParameter(gl.RENDERER);
                    
                    const extensions = gl.getSupportedExtensions();
                    const extensionsHash = extensions ? utils.hashString(extensions.join(',')) : '';
                    
                    detectionResults.browserEnvironment.webGL = {
                        vendor: vendor?.toLowerCase(),
                        renderer: renderer?.toLowerCase(),
                        shadingLanguageVersion: shadingLanguageVersion?.toLowerCase(),
                        webglVersion: webglVersion?.toLowerCase(),
                        vendorName: vendorName?.toLowerCase(),
                        rendererName: rendererName?.toLowerCase(),
                        extensionsHash: extensionsHash
                    };
                    
                    return detectionResults.browserEnvironment.webGL;
                } catch (error) {
                    return { error: error.message };
                }
            },
            
            /**
             * Analyze browser chrome elements like toolbars, menubar, etc.
             */
            getBrowserChrome: function() {
                const chromeFeatures = [];
                const uiElements = ['locationbar', 'menubar', 'personalbar', 'scrollbars', 'statusbar', 'toolbar'];
                let hasNonStandardChrome = false;
                
                for (let i = 0; i < uiElements.length; i++) {
                    const element = window[uiElements[i]];
                    const visibility = element && typeof element.visible === 'boolean' ? 
                        +element.visible : '-';
                    
                    if (visibility !== 1) {
                        hasNonStandardChrome = true;
                    }
                    
                    chromeFeatures.push(visibility);
                }
                
                detectionResults.browserEnvironment.chrome = {
                    features: chromeFeatures,
                    nonStandard: hasNonStandardChrome
                };
                
                return detectionResults.browserEnvironment.chrome;
            },
            
            /**
             * Check for suspicious screen dimensions
             */
            detectScreenAnomalies: function() {
                const screenObj = window.screen;
                
                const hasZeroScreenSize = screenObj.width <= 1 || screenObj.height <= 1;
                const hasZeroAvailableScreenSize = screenObj.availHeight <= 1 || screenObj.availWidth <= 1;
                const hasSmallColorDepth = screenObj.colorDepth <= 8 || screenObj.pixelDepth <= 8 || window.devicePixelRatio <= 0;
                
                detectionResults.browserEnvironment.screen = {
                    zeroSize: hasZeroScreenSize,
                    zeroAvailableSize: hasZeroAvailableScreenSize,
                    smallColorDepth: hasSmallColorDepth,
                    width: screenObj.width,
                    height: screenObj.height,
                    availWidth: screenObj.availWidth,
                    availHeight: screenObj.availHeight,
                    colorDepth: screenObj.colorDepth,
                    pixelDepth: screenObj.pixelDepth,
                    devicePixelRatio: window.devicePixelRatio
                };
                
                return detectionResults.browserEnvironment.screen;
            }
        };
        
        //===============================================================
        // 2. JavaScript Environment Analysis
        //===============================================================
        
        const jsEnvironment = {
            /**
             * Check for native function tampering
             */
            detectNativeFunctionTampering: function() {
                const results = {};
                
                // Check several commonly tampered functions
                const functionPairs = [
                    ['Document.prototype.createElement', Document.prototype.createElement],
                    ['HTMLElement.prototype.getBoundingClientRect', HTMLElement.prototype.getBoundingClientRect],
                    ['navigator.userAgent getter', Object.getOwnPropertyDescriptor(Navigator.prototype, 'userAgent')?.get],
                    ['Date.prototype.getTimezoneOffset', Date.prototype.getTimezoneOffset]
                ];
                
                for (const [name, func] of functionPairs) {
                    if (func) {
                        const isNonNative = utils.isMethodNonNative(func);
                        results[name] = {
                            isModified: isNonNative
                        };
                        
                        if (isNonNative) {
                            results[name].methodBody = utils.getNonNativeMethodString(func);
                        }
                    }
                }
                
                detectionResults.jsEnvironment.nativeFunctionTampering = results;
                return results;
            },
            
            /**
             * Analyze stack traces for patterns indicative of automation
             */
            analyzeStackTrace: function() {
                try {
                    // Generate an artificial error to capture stack trace
                    document.createElement('-');
                } catch (error) {
                    const stack = error.stack || '';
                    
                    // Check for suspicious patterns in stack trace
                    const patterns = [
                        'at callFunction', 
                        'userscript', 
                        'evaluateJavascriptFunction',
                        'evaluation_script',
                        'apply.navigator',
                        'fn (eval at evalFunc)',
                        'eval at evaluate',
                        'utilityscript.evaluate',
                        'pptr.evaluate'
                    ];
                    
                    const detectedPatterns = patterns.filter(pattern => 
                        stack.toLowerCase().includes(pattern.toLowerCase())
                    );
                    
                    detectionResults.jsEnvironment.stackTrace = {
                        suspicious: detectedPatterns.length > 0,
                        detectedPatterns: detectedPatterns,
                        stackSample: stack.substring(0, 256)
                    };
                    
                    return detectionResults.jsEnvironment.stackTrace;
                }
            },
            
            /**
             * Test precision of Math functions to detect emulation
             */
            getMathPrecisionTest: function() {
                try {
                    const testPI = Number('3.141592653589793');
                    
                    // Tests that should match for real browsers, but may fail in emulated environments
                    const checkFirst = eval(testPI + ' ** -100') == +'1.9275814160560204e-50';
                    const checkSecond = eval(testPI + ' ** -100') == +'1.9275814160560185e-50';
                    const checkThird = eval(testPI + ' ** -100') == +'1.9275814160560206e-50';
                    
                    detectionResults.jsEnvironment.mathPrecision = {
                        checkFirst,
                        checkSecond,
                        checkThird,
                        result: '' + +checkFirst + +checkSecond + +checkThird
                    };
                    
                    return detectionResults.jsEnvironment.mathPrecision;
                } catch (error) {
                    return { error: error.message };
                }
            }
        };
        
        //===============================================================
        // 3. Bot Framework Detection
        //===============================================================
        
        const botFramework = {
            /**
             * Detect automation global variables
             */
            detectAutomationGlobals: function() {
                const automationGlobals = [
                    '_phantom',
                    '__nightmare',
                    '_selenium',
                    'callPhantom',
                    'callSelenium',
                    '_Selenium_IDE_Recorder',
                    'domAutomation',
                    'domAutomationController',
                    '_WEBDRIVER_ELEM_CACHE',
                    'wptagentGetInteractivePeriods',
                    'fSCInitialize',
                    '__webdriverFunc',
                    'geb',
                    'awesomium',
                    '$chrome_asyncScriptInfo',
                    'webdriver',
                    '__webdriverFunc',
                    '_WEBDRIVER_ELEM_CACHE',
                    '$cdc_asdjflasutopfhvcZLmcfl_'
                ];
                
                const detectedGlobals = automationGlobals.filter(name => {
                    try {
                        return window[name] !== undefined;
                    } catch (e) {
                        return false;
                    }
                });
                
                detectionResults.botFrameworks.globals = {
                    detected: detectedGlobals.length > 0,
                    detectedGlobals
                };
                
                return detectionResults.botFrameworks.globals;
            },
            
            /**
             * Check for Selenium WebDriver properties
             */
            detectWebdriverProperties: function() {
                let results = {
                    navigatorHasWebdriver: false,
                    documentHasWebdriverAttributes: false
                };
                
                // Check for webdriver property in navigator
                try {
                    if ('webdriver' in navigator) {
                        results.navigatorHasWebdriver = true;
                        results.webdriverValue = navigator.webdriver;
                    }
                } catch (e) {}
                
                // Check for Selenium/WebDriver attributes in DOM
                try {
                    const docElement = document.documentElement;
                    const seleniumAttr = docElement.getAttribute('selenium');
                    const webdriverAttr = docElement.getAttribute('webdriver');
                    const driverAttr = docElement.getAttribute('driver');
                    const cdcAttr = docElement.getAttribute('cd_frame_id_');
                    
                    results.documentHasWebdriverAttributes = !!(seleniumAttr || webdriverAttr || driverAttr || cdcAttr);
                    
                    if (results.documentHasWebdriverAttributes) {
                        results.attributes = {
                            selenium: !!seleniumAttr,
                            webdriver: !!webdriverAttr,
                            driver: !!driverAttr,
                            cd_frame_id_: !!cdcAttr
                        };
                    }
                } catch (e) {}
                
                // Check for hidden webdriver property in navigator
                try {
                    const navProto = Object.getPrototypeOf(navigator);
                    const webdriverPropDesc = Object.getOwnPropertyDescriptor(navProto, 'webdriver');
                    
                    if (webdriverPropDesc) {
                        results.hasWebdriverPropertyDescriptor = true;
                        
                        if (webdriverPropDesc.get && utils.isMethodNonNative(webdriverPropDesc.get)) {
                            results.webdriverGetterModified = true;
                            results.webdriverGetterBody = utils.getNonNativeMethodString(webdriverPropDesc.get);
                        }
                    }
                } catch (e) {}
                
                detectionResults.botFrameworks.webdriver = results;
                return results;
            },
            
            /**
             * Detect Chrome extension for automation
             */
            detectAutomationExtensions: function() {
                const results = {
                    hasChromeExtension: false,
                    hasPrototypeInRuntimeSendMessage: false
                };
                
                // Check for Chrome extension
                if (window.chrome && !!window.chrome.extension) {
                    results.hasChromeExtension = true;
                }
                
                // Check for suspicious Chrome runtime properties
                try {
                    if (window.chrome && window.chrome.runtime && window.chrome.runtime.sendMessage) {
                        results.hasPrototypeInRuntimeSendMessage = !!window.chrome.runtime.sendMessage.prototype;
                    }
                } catch (e) {}
                
                detectionResults.botFrameworks.extensions = results;
                return results;
            }
        };
        
        //===============================================================
        // 4. Browser Behavior Analysis
        //===============================================================
        
        const browserBehavior = {
            /**
             * Set up monitoring for mouse events 
             */
            initMouseMonitoring: function() {
                const state = {
                    movements: [],
                    clicks: [],
                    firstMovementTime: null,
                    firstClickTime: null
                };
                
                const recordMousePosition = function(event, type) {
                    const timestamp = Date.now();
                    const isTrusted = event.isTrusted !== false;
                    
                    const position = {
                        clientX: event.clientX,
                        clientY: event.clientY,
                        pageX: event.pageX,
                        pageY: event.pageY,
                        screenX: event.screenX,
                        screenY: event.screenY,
                        timestamp: timestamp,
                        isTrusted: isTrusted
                    };
                    
                    if (type === 'movement') {
                        if (!state.firstMovementTime) {
                            state.firstMovementTime = timestamp;
                        }
                        state.movements.push(position);
                        
                        // Keep only the last 20 movements
                        if (state.movements.length > 20) {
                            state.movements.shift();
                        }
                    } else if (type === 'click') {
                        if (!state.firstClickTime) {
                            state.firstClickTime = timestamp;
                        }
                        
                        // Try to determine if an element was clicked
                        try {
                            const element = event.target;
                            if (element) {
                                position.element = {
                                    tagName: element.tagName.toLowerCase(),
                                    id: element.id,
                                    className: element.className
                                };
                                
                                // Check for interactive elements
                                position.isInteractive = 
                                    ['button', 'a', 'input', 'select', 'textarea'].includes(position.element.tagName) ||
                                    typeof element.onclick === 'function';
                            }
                        } catch (e) {}
                        
                        state.clicks.push(position);
                        
                        // Keep only the last 10 clicks
                        if (state.clicks.length > 10) {
                            state.clicks.shift();
                        }
                    }
                    
                    // Update detection results
                    detectionResults.browserBehavior.mouse = state;
                };
                
                // Set up listeners
                document.addEventListener('mousemove', e => recordMousePosition(e, 'movement'));
                document.addEventListener('click', e => recordMousePosition(e, 'click'));
                
                return {
                    getState: () => state
                };
            },
            
            /**
             * Set up keyboard event monitoring
             */
            initKeyboardMonitoring: function() {
                const state = {
                    events: [],
                    firstEventTime: null,
                    uniqueKeysPressed: new Set()
                };
                
                const recordKeyEvent = function(event) {
                    const timestamp = Date.now();
                    
                    if (!state.firstEventTime) {
                        state.firstEventTime = timestamp;
                    }
                    
                    const keyEvent = {
                        type: event.type,
                        key: event.key,
                        code: event.code,
                        keyCode: event.keyCode,
                        isTrusted: event.isTrusted !== false,
                        timestamp: timestamp
                    };
                    
                    state.events.push(keyEvent);
                    state.uniqueKeysPressed.add(event.key);
                    
                    // Keep only the last 20 events
                    if (state.events.length > 20) {
                        state.events.shift();
                    }
                    
                    // Update detection results
                    detectionResults.browserBehavior.keyboard = {
                        events: state.events,
                        firstEventTime: state.firstEventTime,
                        uniqueKeysCount: state.uniqueKeysPressed.size
                    };
                };
                
                // Set up listeners
                document.addEventListener('keydown', recordKeyEvent);
                document.addEventListener('keyup', recordKeyEvent);
                
                return {
                    getState: () => detectionResults.browserBehavior.keyboard
                };
            },
            
            /**
             * Monitor tab visibility state changes
             */
            initVisibilityMonitoring: function() {
                const state = {
                    changes: [],
                    currentState: document.visibilityState
                };
                
                const recordVisibilityChange = function() {
                    const timestamp = Date.now();
                    const visibilityState = document.visibilityState;
                    
                    state.changes.push({
                        timestamp: timestamp,
                        state: visibilityState
                    });
                    
                    state.currentState = visibilityState;
                    
                    // Keep only the last 10 changes
                    if (state.changes.length > 10) {
                        state.changes.shift();
                    }
                    
                    // Update detection results
                    detectionResults.browserBehavior.visibility = state;
                };
                
                // Record initial state
                recordVisibilityChange();
                
                // Set up listener
                document.addEventListener('visibilitychange', recordVisibilityChange);
                
                return {
                    getState: () => state
                };
            }
        };
        
        //===============================================================
        // 5. Advanced Fingerprinting
        //===============================================================
        
        const fingerprinting = {
            /**
             * Create canvas fingerprint
             */
            getCanvasFingerprint: function() {
                try {
                    const canvas = document.createElement('canvas');
                    canvas.width = 400;
                    canvas.height = 60;
                    
                    const context = canvas.getContext('2d');
                    
                    // Draw background
                    context.fillStyle = '#f60';
                    context.fillRect(125, 1, 62, 20);
                    
                    // Add text
                    context.fillStyle = '#069';
                    context.font = '11pt Arial';
                    context.fillText('Cwm fjordbank glyphs vext quiz, 😃', 2, 15);
                    
                    // More complex shape
                    context.fillStyle = 'rgba(102, 204, 0, 0.7)';
                    context.font = '18pt Arial';
                    context.fillText('Cwm fjordbank glyphs vext quiz, 😃', 4, 45);
                    
                    // Get fingerprint
                    const fingerprint = canvas.toDataURL();
                    const hash = utils.hashString(fingerprint);
                    
                    detectionResults.fingerprinting.canvas = {
                        hash: hash,
                        // Don't include the full fingerprint string as it's very long
                        sampleLength: fingerprint.length
                    };
                    
                    return detectionResults.fingerprinting.canvas;
                } catch (error) {
                    return { error: error.message };
                }
            },
            
            /**
             * Create audio context fingerprint
             */
            getAudioFingerprint: function() {
                try {
                    const audioContext = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(1, 5000, 44100);
                    
                    const analyser = audioContext.createAnalyser();
                    const oscillator = audioContext.createOscillator();
                    const dynamicsCompressor = audioContext.createDynamicsCompressor();
                    
                    // Set properties for more stable fingerprinting
                    oscillator.type = 'triangle';
                    oscillator.frequency.value = 10000;
                    
                    dynamicsCompressor.threshold.value = -50;
                    dynamicsCompressor.knee.value = 40;
                    dynamicsCompressor.attack.value = 0;
                    
                    oscillator.connect(dynamicsCompressor);
                    dynamicsCompressor.connect(analyser);
                    dynamicsCompressor.connect(audioContext.destination);
                    
                    oscillator.start(0);
                    audioContext.startRendering();
                    
                    const audioData = [];
                    
                    audioContext.oncomplete = function(event) {
                        const samples = event.renderedBuffer.getChannelData(0);
                        
                        // Sample a subset of data points
                        for (let i = 0; i < 20; i++) {
                            const index = Math.floor(samples.length / 20 * i);
                            audioData.push(samples[index]);
                        }
                        
                        const hash = utils.hashString(audioData.join(''));
                        
                        detectionResults.fingerprinting.audio = {
                            hash: hash,
                            sampleCount: audioData.length
                        };
                    };
                    
                    return { started: true };
                } catch (error) {
                    return { error: error.message };
                }
            },
            
            /**
             * Detect installed fonts
             */
            getFontDetection: function() {
                const baseFonts = ['monospace', 'sans-serif', 'serif'];
                const fontList = [
                    'Arial', 'Courier New', 'Georgia', 'Times New Roman', 'Verdana',
                    'Helvetica', 'Tahoma', 'Trebuchet MS', 'Geneva', 'Cambria',
                    'Garamond', 'Palatino', 'Roboto', 'Segoe UI', 'Ubuntu',
                    'DejaVu Sans', 'Liberation Sans'
                ];
                
                const testString = 'mmmmmmmmmmlli';
                const testSize = '72px';
                const h = document.getElementsByTagName('body')[0];
                
                const s = document.createElement('span');
                s.style.fontSize = testSize;
                s.innerHTML = testString;
                
                const defaultWidth = {};
                const defaultHeight = {};
                
                // Get width of text in different base fonts
                for (let index in baseFonts) {
                    s.style.fontFamily = baseFonts[index];
                    h.appendChild(s);
                    defaultWidth[baseFonts[index]] = s.offsetWidth;
                    defaultHeight[baseFonts[index]] = s.offsetHeight;
                    h.removeChild(s);
                }
                
                const detected = [];
                
                // Detect installed fonts
                for (let i = 0; i < fontList.length; i++) {
                    let isDetected = false;
                    
                    for (let j = 0; j < baseFonts.length; j++) {
                        s.style.fontFamily = fontList[i] + ',' + baseFonts[j];
                        h.appendChild(s);
                        
                        const matched = 
                            s.offsetWidth !== defaultWidth[baseFonts[j]] || 
                            s.offsetHeight !== defaultHeight[baseFonts[j]];
                        
                        h.removeChild(s);
                        
                        if (matched) {
                            isDetected = true;
                            break;
                        }
                    }
                    
                    if (isDetected) {
                        detected.push(fontList[i]);
                    }
                }
                
                detectionResults.fingerprinting.fonts = {
                    detectedFonts: detected,
                    detectedCount: detected.length
                };
                
                return detectionResults.fingerprinting.fonts;
            }
        };
        
        //===============================================================
        // 6. Hardware and Device Detection
        //===============================================================
        
        const hardware = {
            /**
             * Enumerate audio/video devices
             */
            getMediaDevices: function() {
                return new Promise((resolve) => {
                    if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
                        detectionResults.hardware.mediaDevices = {
                            available: false
                        };
                        resolve(detectionResults.hardware.mediaDevices);
                        return;
                    }
                    
                    navigator.mediaDevices.enumerateDevices()
                        .then(devices => {
                            const counts = {
                                audioInput: 0,
                                audioOutput: 0,
                                videoInput: 0
                            };
                            
                            devices.forEach(device => {
                                switch (device.kind) {
                                    case 'audioinput':
                                        counts.audioInput++;
                                        break;
                                    case 'audiooutput':
                                        counts.audioOutput++;
                                        break;
                                    case 'videoinput':
                                        counts.videoInput++;
                                        break;
                                }
                            });
                            
                            detectionResults.hardware.mediaDevices = {
                                available: true,
                                counts: counts,
                                total: devices.length
                            };
                            
                            resolve(detectionResults.hardware.mediaDevices);
                        })
                        .catch(error => {
                            detectionResults.hardware.mediaDevices = {
                                available: true,
                                error: error.message
                            };
                            resolve(detectionResults.hardware.mediaDevices);
                        });
                });
            },
            
            /**
             * Get CPU cores and device memory
             */
            getCPUAndMemoryInfo: function() {
                const results = {
                    hardwareConcurrency: navigator.hardwareConcurrency,
                    deviceMemory: navigator.deviceMemory
                };
                
                // Check for suspicious values
                results.suspiciousHardwareConcurrency = 
                    navigator.hardwareConcurrency === undefined || 
                    navigator.hardwareConcurrency <= 1;
                    
                results.suspiciousDeviceMemory = 
                    navigator.deviceMemory === undefined || 
                    navigator.deviceMemory <= 1;
                
                detectionResults.hardware.cpuMemory = results;
                return results;
            },
            
            /**
             * Check for VM backdoors
             */
            detectVMEnvironment: function() {
                const results = {
                    isVM: false,
                    indicators: []
                };
                
                // Check for VMWare
                if (window.vmware && typeof window.vmware === 'object') {
                    results.isVM = true;
                    results.indicators.push('vmware object present');
                }
                
                // Check for VirtualBox
                if (window.VirtualBox && typeof window.VirtualBox === 'object') {
                    results.isVM = true;
                    results.indicators.push('VirtualBox object present');
                }
                
                // Check for other VM properties
                const vmProps = ['vboxrt', 'vboxdtcc'];
                for (const prop of vmProps) {
                    if (window[prop] !== undefined) {
                        results.isVM = true;
                        results.indicators.push(`${prop} property present`);
                    }
                }
                
                detectionResults.hardware.vm = results;
                return results;
            }
        };
        
        //===============================================================
        // 7. Browser API Manipulation Detection
        //===============================================================
        
        const apiManipulation = {
            /**
             * Check for modified navigator properties
             */
            detectNavigatorManipulation: function() {
                const results = {
                    modified: false,
                    modifiedProperties: []
                };
                
                // Properties commonly tampered with
                const propsToCheck = [
                    'userAgent', 'platform', 'vendor', 'appVersion',
                    'language', 'languages', 'plugins', 'mimeTypes'
                ];
                
                // Check each property
                for (const prop of propsToCheck) {
                    try {
                        const descriptor = Object.getOwnPropertyDescriptor(Navigator.prototype, prop);
                        
                        if (descriptor && descriptor.get && utils.isMethodNonNative(descriptor.get)) {
                            results.modified = true;
                            results.modifiedProperties.push({
                                property: prop,
                                details: utils.getNonNativeMethodString(descriptor.get, 100)
                            });
                        }
                    } catch (e) {}
                }
                
                detectionResults.apiManipulation.navigator = results;
                return results;
            },
            
            /**
             * Check for permission API manipulation
             */
            detectPermissionsAPIManipulation: function() {
                const results = {
                    modified: false
                };
                
                try {
                    if (navigator.permissions && navigator.permissions.query) {
                        results.available = true;
                        results.modified = utils.isMethodNonNative(navigator.permissions.query);
                        
                        if (results.modified) {
                            results.methodBody = utils.getNonNativeMethodString(navigator.permissions.query, 100);
                        }
                    } else {
                        results.available = false;
                    }
                } catch (e) {
                    results.error = e.message;
                }
                
                detectionResults.apiManipulation.permissions = results;
                return results;
            },
            
            /**
             * Check for iframe contentWindow manipulation
             */
            detectContentWindowManipulation: function() {
                const results = {
                    modified: false
                };
                
                try {
                    const iframe = document.createElement('iframe');
                    const iframeProto = Object.getPrototypeOf(iframe);
                    
                    // Get descriptor for contentWindow
                    const descriptor = Object.getOwnPropertyDescriptor(iframeProto, 'contentWindow');
                    
                    if (descriptor && descriptor.get) {
                        results.modified = utils.isMethodNonNative(descriptor.get);
                        
                        if (results.modified) {
                            results.methodBody = utils.getNonNativeMethodString(descriptor.get, 100);
                        }
                    }
                } catch (e) {
                    results.error = e.message;
                }
                
                detectionResults.apiManipulation.contentWindow = results;
                return results;
            },
            
            /**
             * Detect timezone manipulation
             */
            detectTimezoneManipulation: function() {
                const results = {
                    modified: false
                };
                
                try {
                    const date = new Date();
                    results.modified = utils.isMethodNonNative(date.getTimezoneOffset);
                    
                    if (results.modified) {
                        results.methodBody = utils.getNonNativeMethodString(date.getTimezoneOffset, 100);
                    }
                    
                    // Gather additional timezone info
                    const timezoneOffset = date.getTimezoneOffset() / 60;
                    
                    let intl;
                    try {
                        intl = Intl.DateTimeFormat().resolvedOptions();
                    } catch (e) {}
                    
                    results.timezoneOffset = timezoneOffset;
                    
                    if (intl) {
                        results.intl = {
                            timeZone: intl.timeZone,
                            locale: intl.locale,
                            calendar: intl.calendar
                        };
                    }
                    
                    // Check for inconsistencies
                    if (intl && intl.timeZone) {
                        // Time zones should roughly match offset
                        // This is a simplistic check - real implementation would be more sophisticated
                        const tzParts = intl.timeZone.split('/');
                        const tzName = tzParts[tzParts.length - 1].toLowerCase();
                        
                        const westCoastNames = ['los_angeles', 'vancouver', 'tijuana', 'pacific'];
                        const eastCoastNames = ['new_york', 'toronto', 'eastern'];
                        const europeanNames = ['london', 'paris', 'berlin', 'rome', 'amsterdam'];
                        const asianNames = ['tokyo', 'shanghai', 'hong_kong', 'singapore'];
                        
                        let expectedRanges = [];
                        
                        if (westCoastNames.some(name => tzName.includes(name.toLowerCase()))) {
                            expectedRanges = [-8, -7]; // PST/PDT
                        } else if (eastCoastNames.some(name => tzName.includes(name.toLowerCase()))) {
                            expectedRanges = [-5, -4]; // EST/EDT
                        } else if (europeanNames.some(name => tzName.includes(name.toLowerCase()))) {
                            expectedRanges = [0, 1, 2]; // GMT/CET
                        } else if (asianNames.some(name => tzName.includes(name.toLowerCase()))) {
                            expectedRanges = [8, 9]; // CST/JST
                        }
                        
                        if (expectedRanges.length > 0) {
                            results.timezoneConsistent = expectedRanges.includes(Math.round(-timezoneOffset));
                        }
                    }
                } catch (e) {
                    results.error = e.message;
                }
                
                detectionResults.apiManipulation.timezone = results;
                return results;
            }
        };
        
        //===============================================================
        // 8. Deception Detection
        //===============================================================
        
        const deception = {
            /**
             * Create bait elements to detect hidden bot interaction
             */
            createHiddenBaitElements: function() {
                const results = {
                    created: false,
                    interactions: []
                };
                
                try {
                    // Create hidden elements
                    const hiddenDiv = document.createElement('div');
                    hiddenDiv.style.cssText = 'opacity:0.01 !important; position:absolute !important; z-index:-990 !important; width:54px !important; height:22px !important;';
                    
                    const hiddenLink = document.createElement('a');
                    hiddenLink.innerHTML = '___';
                    hiddenLink.setAttribute('href', '#');
                    hiddenLink.setAttribute('tabindex', '-1');
                    hiddenLink.setAttribute('aria-hidden', 'true');
                    hiddenLink.setAttribute('rel', 'nofollow');
                    hiddenLink.style.cssText = 'opacity:0.01 !important; position:absolute !important; z-index:-991 !important; width:54px !important; height:22px !important;';
                    
                    // Add event listeners to detect interaction
                    const interactionHandler = function(event) {
                        event.preventDefault();
                        event.stopPropagation();
                        
                        results.interactions.push({
                            type: event.type,
                            timestamp: Date.now(),
                            isTrusted: event.isTrusted !== false,
                            targetId: event.target.id
                        });
                        
                        detectionResults.deception.baitElements = results;
                    };
                    
                    hiddenDiv.addEventListener('click', interactionHandler);
                    hiddenDiv.addEventListener('mouseover', interactionHandler);
                    hiddenLink.addEventListener('click', interactionHandler);
                    hiddenLink.addEventListener('mouseover', interactionHandler);
                    
                    // Add random IDs
                    hiddenDiv.id = 'hb_' + Math.random().toString(36).substring(2, 8);
                    hiddenLink.id = 'hl_' + Math.random().toString(36).substring(2, 8);
                    
                    // Add to document
                    if (document.body) {
                        document.body.appendChild(hiddenDiv);
                        document.body.appendChild(hiddenLink);
                        results.created = true;
                    } else {
                        // Wait for body to be available
                        document.addEventListener('DOMContentLoaded', function() {
                            document.body.appendChild(hiddenDiv);
                            document.body.appendChild(hiddenLink);
                            results.created = true;
                        });
                    }
                    
                    detectionResults.deception.baitElements = results;
                } catch (e) {
                    results.error = e.message;
                    detectionResults.deception.baitElements = results;
                }
                
                return results;
            },
            
            /**
             * Check if events are trusted
             */
            analyzeEventTrust: function() {
                const state = {
                    events: [],
                    untrustedDetected: false
                };
                
                const recordEvent = function(event) {
                    const eventData = {
                        type: event.type,
                        target: event.target.tagName,
                        timestamp: Date.now(),
                        isTrusted: event.isTrusted !== false
                    };
                    
                    state.events.push(eventData);
                    
                    if (!eventData.isTrusted) {
                        state.untrustedDetected = true;
                    }
                    
                    // Keep only the last 20 events
                    if (state.events.length > 20) {
                        state.events.shift();
                    }
                    
                    detectionResults.deception.eventTrust = state;
                };
                
                // Events to monitor
                const eventsToMonitor = [
                    'click', 'mousedown', 'mouseup', 'mousemove',
                    'keydown', 'keyup', 'touchstart', 'touchend'
                ];
                
                // Set up listeners
                for (const eventType of eventsToMonitor) {
                    document.addEventListener(eventType, recordEvent, true);
                }
                
                detectionResults.deception.eventTrust = state;
                return state;
            }
        };
        
        //===============================================================
        // Public API
        //===============================================================
        
        // Initialize behavioral monitoring
        const mouseMonitor = browserBehavior.initMouseMonitoring();
        const keyboardMonitor = browserBehavior.initKeyboardMonitoring();
        const visibilityMonitor = browserBehavior.initVisibilityMonitoring();
        
        // Create bait elements
        deception.createHiddenBaitElements();
        
        // Initialize event trust analysis
        deception.analyzeEventTrust();
        
        return {
            /**
             * Run all detection methods and return a comprehensive report
             */
            runDetection: function() {
                // Browser Environment checks
                browserEnvironment.detectWebGL();
                browserEnvironment.getBrowserChrome();
                browserEnvironment.detectScreenAnomalies();
                
                // JavaScript Environment checks
                jsEnvironment.detectNativeFunctionTampering();
                jsEnvironment.analyzeStackTrace();
                jsEnvironment.getMathPrecisionTest();
                
                // Bot Framework checks
                botFramework.detectAutomationGlobals();
                botFramework.detectWebdriverProperties();
                botFramework.detectAutomationExtensions();
                
                // Advanced fingerprinting
                fingerprinting.getCanvasFingerprint();
                fingerprinting.getAudioFingerprint();
                fingerprinting.getFontDetection();
                
                // Hardware checks
                hardware.getCPUAndMemoryInfo();
                hardware.detectVMEnvironment();
                hardware.getMediaDevices();
                
                // API Manipulation checks
                apiManipulation.detectNavigatorManipulation();
                apiManipulation.detectPermissionsAPIManipulation();
                apiManipulation.detectContentWindowManipulation();
                apiManipulation.detectTimezoneManipulation();
                
                return detectionResults;
            },
            
            /**
             * Get specific detection results
             */
            getResults: function() {
                return detectionResults;
            },
            
            /**
             * Check if there are strong indicators of bot/automation
             */
            isLikelyBot: function() {
                this.runDetection();
                
                const botIndicators = [];
                
                // Check browser environment
                if (detectionResults.browserEnvironment.screen && 
                   (detectionResults.browserEnvironment.screen.zeroSize || 
                    detectionResults.browserEnvironment.screen.zeroAvailableSize ||
                    detectionResults.browserEnvironment.screen.smallColorDepth)) {
                    botIndicators.push('Suspicious screen properties');
                }
                
                // Check JS environment
                if (detectionResults.jsEnvironment.nativeFunctionTampering) {
                    const tamperedFunctions = Object.keys(detectionResults.jsEnvironment.nativeFunctionTampering)
                        .filter(key => detectionResults.jsEnvironment.nativeFunctionTampering[key].isModified);
                    
                    if (tamperedFunctions.length > 0) {
                        botIndicators.push('Modified native functions: ' + tamperedFunctions.join(', '));
                    }
                }
                
                // Check for bot frameworks
                if (detectionResults.botFrameworks.globals && detectionResults.botFrameworks.globals.detected) {
                    botIndicators.push('Automation globals detected: ' + 
                        detectionResults.botFrameworks.globals.detectedGlobals.join(', '));
                }
                
                if (detectionResults.botFrameworks.webdriver && 
                   (detectionResults.botFrameworks.webdriver.navigatorHasWebdriver || 
                    detectionResults.botFrameworks.webdriver.documentHasWebdriverAttributes)) {
                    botIndicators.push('WebDriver detected');
                }
                
                // Check for API manipulation
                if (detectionResults.apiManipulation.navigator && 
                    detectionResults.apiManipulation.navigator.modified) {
                    botIndicators.push('Navigator properties modified');
                }
                
                if (detectionResults.apiManipulation.permissions && 
                    detectionResults.apiManipulation.permissions.modified) {
                    botIndicators.push('Permissions API modified');
                }
                
                if (detectionResults.apiManipulation.contentWindow && 
                    detectionResults.apiManipulation.contentWindow.modified) {
                    botIndicators.push('ContentWindow API modified');
                }
                
                if (detectionResults.apiManipulation.timezone && 
                    detectionResults.apiManipulation.timezone.modified) {
                    botIndicators.push('Timezone API modified');
                }
                
                // Check for suspicious hardware/VM
                if (detectionResults.hardware.vm && detectionResults.hardware.vm.isVM) {
                    botIndicators.push('VM environment detected');
                }
                
                // Check for untrusted events
                if (detectionResults.deception.eventTrust && 
                    detectionResults.deception.eventTrust.untrustedDetected) {
                    botIndicators.push('Untrusted events detected');
                }
                
                // Check for bait element interaction
                if (detectionResults.deception.baitElements && 
                    detectionResults.deception.baitElements.interactions.length > 0) {
                    botIndicators.push('Interaction with hidden bait elements');
                }
                
                return {
                    isBot: botIndicators.length > 0,
                    botScore: botIndicators.length,
                    indicators: botIndicators
                };
            },
            
            /**
             * Utility methods
             */
            utils: utils
        };
    })();

    // Display results in a readable format
    function displayResults(results) {
        const resultsDiv = document.getElementById('results');
        const summaryDiv = document.getElementById('summary');
        const statusDiv = document.getElementById('status');
        
        // Update status
        statusDiv.innerHTML = 'Detection completed. Results are displayed below.';
        statusDiv.className = 'status-complete';
        
        // Create summary
        const botCheck = BotDetector.isLikelyBot();
        
        const summaryHTML = `
            <h2>Detection Summary</h2>
            <div style="padding: 10px; margin-bottom: 15px; border-radius: 4px; background-color: ${botCheck.isBot ? '#ffebee' : '#e8f5e9'}; 
                          border: 1px solid ${botCheck.isBot ? '#ffcdd2' : '#c8e6c9'};">
                <strong style="font-size: 1.2em;">Result: ${botCheck.isBot ? '🚨 AUTOMATION DETECTED 🚨' : '✅ NO AUTOMATION DETECTED'}</strong>
                <br>Bot Score: ${botCheck.botScore} / 11 possible indicators
                ${botCheck.indicators.length > 0 ? 
                    `<br><br><strong>Detected:</strong><br>${botCheck.indicators.map(i => `• ${i}`).join('<br>')}` : 
                    ''
                }
            </div>
        `;
        
        summaryDiv.innerHTML = summaryHTML;
        summaryDiv.className = botCheck.isBot ? 'summary-bot' : 'summary-clean';
        
        // Browser Environment
        appendCategory(resultsDiv, '1. Browser Environment', 'Environment properties that indicate automation');
        
        appendSubcategory(resultsDiv, 'WebGL', 'WebGL rendering engine details');
        appendResult(resultsDiv, 'WebGL Vendor', results.browserEnvironment.webGL?.vendor, 
            'Real browsers show actual GPU vendor (Intel, NVIDIA, AMD). Headless/Automated browsers may show generic values or be blank.');
            
        appendResult(resultsDiv, 'WebGL Renderer', results.browserEnvironment.webGL?.renderer, 
            'Real browsers show actual GPU model. Headless/Automated browsers may show "Mesa", "SwiftShader", or generic values.');
            
        appendSubcategory(resultsDiv, 'Browser Chrome Elements', 'UI components like toolbars, status bar');
        appendResult(resultsDiv, 'Non-Standard Chrome', results.browserEnvironment.chrome?.nonStandard ? 'Yes' : 'No', 
            'Real browsers typically have standard UI elements visible. Headless browsers often have these disabled.');
            
        appendSubcategory(resultsDiv, 'Screen Properties', 'Display characteristics');
        appendResult(resultsDiv, 'Screen Size', 
            `${results.browserEnvironment.screen?.width}x${results.browserEnvironment.screen?.height}`, 
            'Automated browsers may have unusual dimensions (like 0 or very small values).');
            
        appendResult(resultsDiv, 'Color Depth', results.browserEnvironment.screen?.colorDepth, 
            'Real browsers typically have 24 or 32 bit color depth. Bots may have low values like 8 or 0.');
            
        appendResult(resultsDiv, 'Zero/Small Screen', 
            results.browserEnvironment.screen?.zeroSize || 
            results.browserEnvironment.screen?.zeroAvailableSize || 
            results.browserEnvironment.screen?.smallColorDepth ? 'Yes (Suspicious)' : 'No', 
            'Headless browsers often have zero or very small dimensions, indicating automation.');
        
        // JavaScript Environment
        appendCategory(resultsDiv, '2. JavaScript Environment', 'JavaScript execution analysis');
        
        appendSubcategory(resultsDiv, 'Native Function Tampering', 'Modified browser functions');
        
        const tamperedFunctions = results.jsEnvironment.nativeFunctionTampering ? 
            Object.keys(results.jsEnvironment.nativeFunctionTampering)
                .filter(key => results.jsEnvironment.nativeFunctionTampering[key].isModified) : [];
                
        appendResult(resultsDiv, 'Modified Functions', 
            tamperedFunctions.length > 0 ? tamperedFunctions.join(', ') : 'None', 
            'Real browsers have native functions. Automation tools often modify these to hide their presence.');
            
        appendSubcategory(resultsDiv, 'Stack Trace Analysis', 'JavaScript error stack inspection');
        appendResult(resultsDiv, 'Suspicious Patterns', 
            results.jsEnvironment.stackTrace?.suspicious ? 'Yes' : 'No', 
            'Real browsers have standard stack traces. Automation frameworks may leave traces in error stacks.');
            
        if (results.jsEnvironment.stackTrace?.detectedPatterns?.length > 0) {
            appendResult(resultsDiv, 'Stack Patterns Found', 
                results.jsEnvironment.stackTrace.detectedPatterns.join(', '), 
                'Patterns like "evaluate", "callFunction", "userscript" indicate automation frameworks.');
        }
        
        appendSubcategory(resultsDiv, 'Math Precision', 'Floating point calculation accuracy');
        appendResult(resultsDiv, 'Consistent Math', 
            results.jsEnvironment.mathPrecision?.result, 
            'Real browsers have consistent Math precision. VMs or emulated environments may have inconsistencies.');
        
        // Bot Framework Detection
        appendCategory(resultsDiv, '3. Bot Framework Detection', 'Direct indicators of automation frameworks');
        
        appendSubcategory(resultsDiv, 'Automation Global Variables', 'Framework-specific global variables');
        appendResult(resultsDiv, 'Detected Globals', 
            results.botFrameworks.globals?.detected ? 
                results.botFrameworks.globals.detectedGlobals.join(', ') : 'None', 
            'Real browsers should have none. Variables like "_selenium", "callPhantom", etc. indicate automation tools.');
            
        appendSubcategory(resultsDiv, 'WebDriver Properties', 'Selenium/WebDriver indicators');
        appendResult(resultsDiv, 'Navigator WebDriver', 
            results.botFrameworks.webdriver?.navigatorHasWebdriver ? 
                `Present: ${results.botFrameworks.webdriver.webdriverValue}` : 'Not Present', 
            'Real browsers should not have navigator.webdriver=true. This is a direct sign of WebDriver/Selenium.');
            
        appendResult(resultsDiv, 'DOM WebDriver Attributes', 
            results.botFrameworks.webdriver?.documentHasWebdriverAttributes ? 'Present' : 'Not Present', 
            'Real browsers should not have "selenium", "webdriver", or "driver" attributes on HTML elements.');
            
        appendSubcategory(resultsDiv, 'Chrome Extension Patterns', 'Automation extension indicators');
        appendResult(resultsDiv, 'Chrome Extension Properties', 
            results.botFrameworks.extensions?.hasChromeExtension ? 'Present' : 'Not Present', 
            'Some automation frameworks use Chrome extensions which add unique properties.');
        
        // Browser Behavior
        appendCategory(resultsDiv, '4. Browser Behavior', 'User interaction patterns');
        
        appendSubcategory(resultsDiv, 'Mouse Movement', 'Mouse tracking analysis');
        appendResult(resultsDiv, 'Mouse Movements', 
            results.browserBehavior.mouse?.movements?.length || 0, 
            'Real users generate many natural mouse movements. Bots may have none or very straight/unnatural patterns.');
            
        appendResult(resultsDiv, 'Mouse Clicks', 
            results.browserBehavior.mouse?.clicks?.length || 0, 
            'Real users click naturally. Bots may have perfectly precise clicks or clicks before movements.');
            
        appendSubcategory(resultsDiv, 'Keyboard Activity', 'Keyboard event patterns');
        appendResult(resultsDiv, 'Keyboard Events', 
            results.browserBehavior.keyboard?.events?.length || 0, 
            'Real users generate keyboard events naturally. Bots may have none or unusual patterns/timing.');
            
        appendSubcategory(resultsDiv, 'Tab Visibility', 'Browser tab focus states');
        appendResult(resultsDiv, 'Visibility State', 
            results.browserBehavior.visibility?.currentState, 
            'Real users typically have "visible" state. Headless browsers may show "hidden".');
        
        // Fingerprinting
        appendCategory(resultsDiv, '5. Advanced Fingerprinting', 'Unique browser identification methods');
        
        appendSubcategory(resultsDiv, 'Canvas Fingerprinting', 'Graphics rendering uniqueness');
        appendResult(resultsDiv, 'Canvas Hash', 
            results.fingerprinting.canvas?.hash, 
            'Each browser has a unique canvas fingerprint. Bots often have identical or missing fingerprints.');
            
        appendSubcategory(resultsDiv, 'Audio Fingerprinting', 'Audio processing uniqueness');
        appendResult(resultsDiv, 'Audio API', 
            results.fingerprinting.audio?.hash || 'Processing...', 
            'Real browsers have unique audio processing. Headless environments may have consistent or missing values.');
            
        appendSubcategory(resultsDiv, 'Font Detection', 'System fonts available');
        appendResult(resultsDiv, 'Detected Fonts Count', 
            results.fingerprinting.fonts?.detectedCount || 0, 
            'Real browsers have many system fonts available. Headless environments often have few or standard set only.');
        
        // Hardware Detection
        appendCategory(resultsDiv, '6. Hardware & Device Detection', 'Physical device characteristics');
        
        appendSubcategory(resultsDiv, 'CPU & Memory', 'System resources');
        appendResult(resultsDiv, 'CPU Cores', 
            results.hardware.cpuMemory?.hardwareConcurrency, 
            'Real browsers typically report actual CPU cores. Bots may report 1 or modified values.');
            
        appendResult(resultsDiv, 'Device Memory', 
            results.hardware.cpuMemory?.deviceMemory ? `${results.hardware.cpuMemory.deviceMemory}GB` : 'Not reported', 
            'Real browsers typically report actual memory. Bots may report very low values.');
            
        appendSubcategory(resultsDiv, 'Media Devices', 'Audio/Video hardware');
        
        let mediaDeviceText = 'Loading...';
        if (results.hardware.mediaDevices) {
            if (!results.hardware.mediaDevices.available) {
                mediaDeviceText = 'API Not Available';
            } else if (results.hardware.mediaDevices.error) {
                mediaDeviceText = `Error: ${results.hardware.mediaDevices.error}`;
            } else if (results.hardware.mediaDevices.counts) {
                mediaDeviceText = `Audio In: ${results.hardware.mediaDevices.counts.audioInput}, ` +
                                 `Audio Out: ${results.hardware.mediaDevices.counts.audioOutput}, ` +
                                 `Video: ${results.hardware.mediaDevices.counts.videoInput}`;
            }
        }
        
        appendResult(resultsDiv, 'Available Devices', 
            mediaDeviceText, 
            'Real browsers typically have some media devices. Headless environments often have none.');
            
        appendSubcategory(resultsDiv, 'VM Detection', 'Virtual Machine indicators');
        appendResult(resultsDiv, 'VM Environment', 
            results.hardware.vm?.isVM ? `Yes (${results.hardware.vm.indicators.join(', ')})` : 'No', 
            'Real users rarely use VMs with visible VM objects. Bots often run in detectable virtual environments.');
        
        // API Manipulation
        appendCategory(resultsDiv, '7. API Manipulation', 'Browser API tampering detection');
        
        appendSubcategory(resultsDiv, 'Navigator Properties', 'Browser identity properties');
        
        const modifiedNavProps = results.apiManipulation.navigator?.modifiedProperties || [];
        appendResult(resultsDiv, 'Modified Navigator', 
            results.apiManipulation.navigator?.modified ? 
                `Yes (${modifiedNavProps.map(p => p.property).join(', ')})` : 'No', 
            'Real browsers have standard navigator properties. Bots often modify these to mask their identity.');
            
        appendSubcategory(resultsDiv, 'Permissions API', 'Browser permissions system');
        appendResult(resultsDiv, 'Modified Permissions', 
            results.apiManipulation.permissions?.modified ? 'Yes' : 'No', 
            'Real browsers have standard permissions API. Bots may modify this to avoid permission prompts.');
            
        appendSubcategory(resultsDiv, 'IFrame Content Window', 'IFrame security boundaries');
        appendResult(resultsDiv, 'Modified ContentWindow', 
            results.apiManipulation.contentWindow?.modified ? 'Yes' : 'No', 
            'Real browsers respect iframe boundaries. Bots may modify these to gain cross-origin access.');
            
        appendSubcategory(resultsDiv, 'Timezone Consistency', 'Geographic time settings');
        appendResult(resultsDiv, 'Timezone Data', 
            `${results.apiManipulation.timezone?.intl?.timeZone || 'Unknown'} (UTC${results.apiManipulation.timezone?.timezoneOffset > 0 ? '-' : '+'}${Math.abs(results.apiManipulation.timezone?.timezoneOffset || 0)})`, 
            'Real browsers have consistent timezone between methods. Bots may have inconsistent timezone values.');
            
        appendResult(resultsDiv, 'Timezone Modified', 
            results.apiManipulation.timezone?.modified ? 'Yes' : 'No', 
            'Real browsers have native timezone functions. Bots often modify these to fake location.');
        
        // Deception Detection
        appendCategory(resultsDiv, '8. Deception Detection', 'Honesty/inconsistency checks');
        
        appendSubcategory(resultsDiv, 'Bait Elements', 'Hidden element interaction');
        appendResult(resultsDiv, 'Bait Interactions', 
            results.deception.baitElements?.interactions.length > 0 ? 
                `Yes (${results.deception.baitElements.interactions.length})` : 'None', 
            'Real users never interact with invisible elements. Bots sometimes examine all page elements.');
            
        appendSubcategory(resultsDiv, 'Event Trust', 'Event authenticity');
        appendResult(resultsDiv, 'Untrusted Events', 
            results.deception.eventTrust?.untrustedDetected ? 'Yes' : 'No', 
            'Real user events are trusted by browsers. Programmatically generated events are marked untrusted.');
    }
    
    // Helper functions for display
    function appendCategory(parent, title, description) {
        const categoryDiv = document.createElement('div');
        categoryDiv.className = 'category';
        categoryDiv.innerHTML = `<strong>${title}</strong> - ${description}`;
        parent.appendChild(categoryDiv);
    }
    
    function appendSubcategory(parent, title, description) {
        const subcategoryDiv = document.createElement('div');
        subcategoryDiv.className = 'subcategory';
        subcategoryDiv.innerHTML = `${title} <span style="font-weight: normal; font-style: italic; font-size: 0.9em;">(${description})</span>`;
        parent.appendChild(subcategoryDiv);
    }
    
    function appendResult(parent, name, value, expected) {
        const resultDiv = document.createElement('div');
        resultDiv.className = 'result-item';
        
        let valueDisplay = value;
        // For arrays or complex values
        if (typeof value === 'object' && value !== null) {
            try {
                valueDisplay = JSON.stringify(value);
            } catch (e) {
                valueDisplay = String(value);
            }
        }
        
        // For undefined or null
        if (value === undefined) {
            valueDisplay = 'undefined';
        } else if (value === null) {
            valueDisplay = 'null';
        }
        
        resultDiv.innerHTML = `
            <strong>${name}:</strong> ${valueDisplay}
            <div class="expected">Expected: ${expected}</div>
        `;
        parent.appendChild(resultDiv);
    }
    
    // Run detection when DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
        // Run detection immediately
        const results = BotDetector.runDetection();
        
        // Display the results
        displayResults(results);
        
        // Set up periodic updates for behavioral detection
        setInterval(function() {
            displayResults(BotDetector.getResults());
        }, 2000);
    });
    </script>
</body>
</html>
