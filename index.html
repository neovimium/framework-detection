<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Browser Automation Detection</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #333;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }
        
        .results {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #f9f9f9;
            min-height: 200px;
        }
        
        .detection {
            margin-bottom: 10px;
            padding: 8px;
            border-left: 4px solid #ff6b6b;
            background-color: #fff0f0;
        }
        
        .no-detection {
            color: #2e7d32;
            font-weight: bold;
        }
        
        .timestamp {
            color: #888;
            font-size: 0.8em;
            margin-top: 4px;
        }
        
        .info-box {
            background-color: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 10px 15px;
            margin: 15px 0;
            border-radius: 4px;
        }
        
        .info-box h3 {
            margin-top: 0;
            color: #0d47a1;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Browser Automation Detection</h1>
        <p>This page runs various detection techniques to identify browser automation frameworks like Selenium, Puppeteer, Playwright, and others.</p>
        <div id="status">Running detection checks...</div>
        <div class="info-box">
            <h3>About This Tool</h3>
            <p>This detector is designed to detect <strong>actual automation tools</strong>, not normal browser features. The script has been calibrated to minimize false positives in standard browser environments.</p>
            <p>Some browsers may naturally have properties that resemble automation tools, but these are not included in our detection algorithm.</p>
        </div>
        <div id="results" class="results">
            <p>Detection results will appear here...</p>
        </div>
    </div>

    <script>
    (function() {
        const detectionLog = [];
        const resultsElement = document.getElementById('results');
        const statusElement = document.getElementById('status');

        function recordDetection(type, details) {
            const logEntry = { type, details: details || {}, timestamp: Date.now() };
            detectionLog.push(logEntry);
            console.warn(`[AUTOMATION DETECTED] Type: ${type}`, details || '');
            
            // Add to UI
            const detectionElement = document.createElement('div');
            detectionElement.className = 'detection';
            const detectionTime = new Date(logEntry.timestamp).toLocaleTimeString();
            
            let detailsText = '';
            if (details) {
                try {
                    detailsText = JSON.stringify(details);
                } catch (e) {
                    detailsText = '(Complex object)';
                }
            }
            
            detectionElement.innerHTML = `
                <strong>${type}</strong>
                <div>${detailsText}</div>
                <div class="timestamp">${detectionTime}</div>
            `;
            resultsElement.appendChild(detectionElement);
        }

        function isMethodNonNative(method) {
            if (!method || typeof method !== 'function') return false;
            return !/\{\s*\[native code\]\s*\}/.test(Function.prototype.toString.call(method));
        }

        function getNonNativeMethodBody(method, maxLength = 200) {
            if (!method || typeof method !== 'function' || isMethodNonNative(method) === false) return "";
            try {
                const methodString = Function.prototype.toString.call(method);
                return methodString.replace(/^function\s*\(.*?\)\s*\{/, '').replace(/\s*\}$/, '').substring(0, maxLength);
            } catch (e) {
                return "";
            }
        }

        function checkNavigatorWebdriver() {
            // Only detect if navigator.webdriver is explicitly true
            if (navigator.webdriver === true) {
                recordDetection('navigator.webdriver', { value: true });
            }
            
            // Modern browsers might have this property but it doesn't mean automation
            // Only check for non-standard implementation
            try {
                const descriptor = Object.getOwnPropertyDescriptor(Navigator.prototype, 'webdriver');
                if (descriptor && descriptor.get && isMethodNonNative(descriptor.get)) {
                    recordDetection('navigator.webdriver_modified_getter', { 
                        nonNativeCode: getNonNativeMethodBody(descriptor.get) 
                    });
                }
            } catch (e) { /* ignore */ }
        }

        function checkGlobalVariables() {
            const automationGlobals = [
                '_phantom', '__nightmare', '_selenium', 'callPhantom', 'callSelenium',
                '_Selenium_IDE_Recorder', 'domAutomation', 'domAutomationController',
                '_WEBDRIVER_ELEM_CACHE', 'wptagentGetInteractivePeriods', 'fSCInitialize',
                '__webdriverFunc', 'geb', 'awesomium', '$chrome_asyncScriptInfo',
                'webdriver',
                '$cdc_asdjflasutopfhvcZLmcfl_',
                '_evaluate', 'spawn', 'emit',
                'Cypress', 'Sahi', '_sahi', 'ubot', 'UBotCookies'
            ];
            
            for (const prop of automationGlobals) {
                if (window[prop] !== undefined) {
                    recordDetection('global_variable', { property: prop, value: typeof window[prop] });
                }
            }
            
            for (const key of Object.keys(window)) {
                if (/^cdc_[a-zA-Z0-9]{22}_(Array|Promise|Symbol)$/.test(key)) {
                    recordDetection('global_variable_cdc', { property: key });
                }
            }
        }

        function checkDocumentPropertiesAndAttributes() {
            const documentProps = [
                '__webdriver_script_fn', '__webdriver_script_f', '__$webdriverAsyncExecutor',
                '__webdriverevaluate', '__seleniumevaluate', '__webdriver_script_function',
                '__webdriver_script_func', '__fxdriver_evaluate', '__driver_unwrapped',
                '__webdriver_unwrapped', '__driver_evaluate', '__selenium_unwrapped',
                '__fxdriver_unwrapped', '$chrome_asyncScriptInfo', '$xwalk_asyncScriptInfo'
            ];
            
            for (const prop of documentProps) {
                if (document[prop] !== undefined) {
                    recordDetection('document_property', { property: prop });
                }
            }
            
            for (const key of Object.keys(document)) {
                if (/\$[a-z]dc_/.test(key)) {
                    recordDetection('document_property_pattern', { property: key });
                }
                
                try {
                    if (document[key] && document[key]['_cacdc'] && document[key]['selenium-ide']) {
                        recordDetection('document_property_custom_attributes', { property: key, attributes: ['_cacdc', 'selenium-ide'] });
                    }
                } catch(e) { /* ignore */ }
            }

            const attributesToCheck = ['selenium', 'webdriver', 'driver', 'cd_frame_id_'];
            for (const attr of attributesToCheck) {
                if (document.documentElement && document.documentElement.hasAttribute(attr)) {
                    recordDetection('documentElement_attribute', { attribute: attr, value: document.documentElement.getAttribute(attr) });
                }
            }

            if (document.cookie.includes('ChromeDriverwjers908fljsdf37459fsdfgdfwru=')) {
                recordDetection('chromedriver_cookie');
            }
        }

        function setupStackTraceAnalysis() {
            const automationPatterns = /at\scallFunction\s\(\<anonymous|userscript\:Scraper|evaluateJavascriptFunction|evaluation_script|\.apply\.navigator|(at fn \(eval at evalFunc)|eval\sat\sevaluate|utilityscript.evaluate|pptr.evaluate/i;

            function getStack() {
                try {
                    null[0](); // Force an error
                } catch (e) {
                    return e.stack || "";
                }
                return "";
            }

            function checkStack(source) {
                const stack = getStack();
                if (automationPatterns.test(stack)) {
                    recordDetection('stack_trace_automation', { source: source, stack: stack.substring(0, 200) });
                    return true;
                }
                
                if (stack.includes('Taiko') || stack.includes('waitForPredicatePageFunction')) {
                    recordDetection('stack_trace_taiko', { source: source, stack: stack.substring(0, 200) });
                    return true;
                }
                return false;
            }

            const methodsToInstrument = {
                'Document.evaluate': Document.prototype.evaluate,
                'Element.getAttributeNode': Element.prototype.getAttributeNode,
                'Element.getClientRects': Element.prototype.getClientRects,
                'Document.querySelector': Document.prototype.querySelector,
                'Document.querySelectorAll': Document.prototype.querySelectorAll,
                'XMLSerializer.serializeToString': XMLSerializer.prototype.serializeToString,
                'IntersectionObserver.observe': window.IntersectionObserver ? IntersectionObserver.prototype.observe : null,
                'window.scrollBy': window.scrollBy,
                'window.scrollTo': window.scrollTo
            };

            for (const methodName in methodsToInstrument) {
                const originalMethod = methodsToInstrument[methodName];
                if (originalMethod && typeof originalMethod === 'function') {
                    const parts = methodName.split('.');
                    let obj = window;
                    const actualMethodName = parts[parts.length-1];
                    
                    if (parts.length > 1) {
                        if (window[parts[0]] && window[parts[0]].prototype) {
                            obj = window[parts[0]].prototype;
                            obj[actualMethodName] = function(...args) {
                                checkStack(`call_to_${methodName}`);
                                return originalMethod.apply(this, args);
                            };
                        } else if (window[parts[0]]) {
                            obj = window[parts[0]];
                            obj[actualMethodName] = function(...args) {
                                checkStack(`call_to_${methodName}`);
                                return originalMethod.apply(this, args);
                            };
                        }
                    } else if (methodName.startsWith('window.')) {
                        window[actualMethodName] = function(...args) {
                            checkStack(`call_to_${methodName}`);
                            return originalMethod.apply(this, args);
                        };
                    }
                }
            }

            if (window.Promise) {
                const OriginalPromise = window.Promise;
                window.Promise = new Proxy(OriginalPromise, {
                    construct: function(target, args) {
                        checkStack('Promise_constructor');
                        return Reflect.construct(target, args);
                    }
                });
            }

            window.addEventListener('click', function(event) {
                if (event.isTrusted === false) {
                    if (checkStack('untrusted_click_event')) {
                        recordDetection('untrusted_click_with_automation_stack', { target: event.target ? event.target.tagName : 'unknown' });
                    }
                }
            }, true);
        }

        function checkErrorObjectManipulation() {
            // Skip this test as it frequently produces false positives in normal browsers
            // The error.stack property interaction has changed in modern browsers
            // which makes this test unreliable
            
            // Only run the more specific test for automation tools that actually
            // modify DevTools behavior
            if (window.Worker && window.Blob && window.URL && window.URL.createObjectURL) {
                try {
                    const workerScript = `
                        onmessage = function() {
                            const detectionResult = {
                                hasDevToolsHook: false,
                                modifiedStack: false,
                                reasons: []
                            };
                            
                            try {
                                // Test for specific DevTools hooks, not just any stack property access
                                const originalConsoleLog = console.log;
                                let consoleLogCalled = false;
                                
                                console.log = function() {
                                    consoleLogCalled = true;
                                    return originalConsoleLog.apply(console, arguments);
                                };
                                
                                // Force an error and read its stack in a way that would trigger DevTools
                                const err = new Error('DetectionTest');
                                const stackProp = Object.getOwnPropertyDescriptor(err, 'stack');
                                
                                // Only report if we detect actual modification by automation tools
                                if (stackProp && stackProp.get && /automationTool|selenium|puppeteer|playwright/i.test(stackProp.get.toString())) {
                                    detectionResult.hasDevToolsHook = true;
                                    detectionResult.reasons.push('Stack getter contains automation strings');
                                }
                                
                                // Restore console.log
                                console.log = originalConsoleLog;
                                
                                // Only report if we're confident this is automation behavior
                                postMessage(detectionResult);
                            } catch (e) {
                                postMessage({ error: e.toString() });
                            }
                        };
                    `;
                    const blob = new Blob([workerScript], { type: 'application/javascript' });
                    const url = URL.createObjectURL(blob);
                    const worker = new Worker(url);
                    worker.onmessage = function(e) {
                        if (e.data.hasDevToolsHook) {
                            recordDetection('devtools_hooks_detected', e.data);
                        }
                        worker.terminate();
                        URL.revokeObjectURL(url);
                    };
                    worker.postMessage({});
                } catch (e) {
                    console.error("Worker check failed to setup:", e);
                }
            }
        }

        function checkMutationObserverAttributes() {
            if (window.MutationObserver && document.body) {
                const observer = new MutationObserver(function(mutations) {
                    for (const mutation of mutations) {
                        if (mutation.type === 'attributes' && mutation.attributeName === 'selenium-ide-indicator') {
                            recordDetection('mutation_selenium_ide_indicator');
                            observer.disconnect();
                            return;
                        }
                    }
                });
                observer.observe(document.body, { attributes: true });
            }
        }

        function listenWebDriverEvents() {
            const webdriverEvents = [
                'driver-evaluate', 'webdriver-evaluate', 'webdriver-evaluate-response',
                'webdriverCommand', 'selenium-evaluate'
            ];
            
            for (const eventName of webdriverEvents) {
                document.addEventListener(eventName, function(event) {
                    recordDetection('webdriver_event', { type: event.type });
                }, true);
            }
        }

        function checkCEF() {
            if (typeof window.cefQuery === 'function' || typeof window.cefQueryCancel === 'function') {
                recordDetection('cef_properties', {
                    cefQuery: typeof window.cefQuery,
                    cefQueryCancel: typeof window.cefQueryCancel
                });
            }
        }

        function checkModifiedNativeFunctions() {
            const functionsToCheck = {
                'navigator.permissions.query': navigator.permissions ? navigator.permissions.query : null,
                'document.cookie_getter': Object.getOwnPropertyDescriptor(Document.prototype, 'cookie') ? 
                    Object.getOwnPropertyDescriptor(Document.prototype, 'cookie').get : null,
                'document.cookie_setter': Object.getOwnPropertyDescriptor(Document.prototype, 'cookie') ? 
                    Object.getOwnPropertyDescriptor(Document.prototype, 'cookie').set : null,
                'HTMLIFrameElement.contentWindow': Object.getOwnPropertyDescriptor(HTMLIFrameElement.prototype, 'contentWindow') ? 
                    Object.getOwnPropertyDescriptor(HTMLIFrameElement.prototype, 'contentWindow').get : null,
                'Canvas.getContext': HTMLCanvasElement.prototype.getContext,
                'Canvas.toDataURL': HTMLCanvasElement.prototype.toDataURL,
                'WebGL.getParameter': window.WebGLRenderingContext ? WebGLRenderingContext.prototype.getParameter : null,
                'Date.getTimezoneOffset': Date.prototype.getTimezoneOffset,
                'Intl.DateTimeFormat': window.Intl ? Intl.DateTimeFormat : null,
                'document.createElement': document.createElement
            };

            for (const name in functionsToCheck) {
                const func = functionsToCheck[name];
                if (func && isMethodNonNative(func)) {
                    recordDetection('modified_native_function', { name: name, body: getNonNativeMethodBody(func) });
                }
            }
        }
        
        function checkElectron() {
            try {
                if (window.close && typeof window.close === 'function' && window.close.toString().includes("ELECTRON")) {
                    recordDetection('electron_close_method');
                }
            } catch(e) { /*ignore*/ }
        }

        function checkPrototypeChain() {
            if (Navigator.prototype && Object.getPrototypeOf(navigator) !== Navigator.prototype) {
                recordDetection('navigator_prototype_modified');
            }
        }
        
        function checkClonedPrototypes() {
            const props = Object.getOwnPropertyNames(window);
            const cdcArray = props.find(p => /^cdc_[a-zA-Z0-9]{22}_Array$/.test(p));
            const cdcSymbol = props.find(p => /^cdc_[a-zA-Z0-9]{22}_Symbol$/.test(p));
            const cdcPromise = props.find(p => /^cdc_[a-zA-Z0-9]{22}_Promise$/.test(p));

            if (cdcArray && window[cdcArray] === window.Array &&
                cdcSymbol && window[cdcSymbol] === window.Symbol &&
                cdcPromise && window[cdcPromise] === window.Promise) {
                recordDetection('cloned_prototypes_cdc_pattern', {array: cdcArray, symbol: cdcSymbol, promise: cdcPromise});
            }
        }

        function updateSummary() {
            if (detectionLog.length > 0) {
                statusElement.innerHTML = `<strong style="color: #ff6b6b;">Automation Detected!</strong> Found ${detectionLog.length} indicators.`;
                console.warn("--- Automation Detection Summary ---");
                detectionLog.forEach(log => console.warn(`[DETECTED] Type: ${log.type}`, log.details));
                console.warn("--- End of Summary ---");
            } else {
                statusElement.innerHTML = '<strong style="color: #2e7d32;">No Automation Detected</strong>';
                resultsElement.innerHTML = '<p class="no-detection">No direct automation framework artifacts were detected by this script.</p>';
                console.log("No direct automation framework artifacts detected by this script.");
            }
        }

        function runChecks() {
            console.log("Starting automation framework detection checks...");
            resultsElement.innerHTML = '<p>Running checks...</p>';

            // Most reliable checks first
            if (navigator.webdriver === true) {
                recordDetection('navigator.webdriver', { value: true });
            }
            
            checkGlobalVariables();
            checkDocumentPropertiesAndAttributes();
            checkCEF();
            checkModifiedNativeFunctions();
            checkElectron();
            checkPrototypeChain();
            checkClonedPrototypes();
            
            // More specific reliable checks
            listenWebDriverEvents();
            setupStackTraceAnalysis();
            
            // Add DOM-dependent checks only when DOM is ready
            if (document.readyState === 'complete' || document.readyState === 'interactive') {
                checkMutationObserverAttributes();
                // Remove the unreliable checks that cause false positives
                // checkErrorObjectManipulation();
                checkNavigatorWebdriver(); // Our updated version only checks for non-standard implementations
            } else {
                window.addEventListener('DOMContentLoaded', () => {
                    checkMutationObserverAttributes();
                    // checkErrorObjectManipulation();
                    checkNavigatorWebdriver();
                });
            }

            setTimeout(updateSummary, 2000);
        }
        
        runChecks();
    })();
    </script>
</body>
</html>
